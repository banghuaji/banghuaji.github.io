{"meta":{"title":"JIMI的博客","subtitle":"想取个能够唬住人的标题到今天也没找到","description":"努力超越那个谁","author":"JIMI","url":"https://banghuaji.github.io"},"pages":[{"title":"","date":"2017-10-01T12:38:16.285Z","updated":"2017-10-01T12:37:48.000Z","comments":true,"path":"404.html","permalink":"https://banghuaji.github.io/404.html","excerpt":"","text":""},{"title":"categories","date":"2017-10-01T13:21:45.000Z","updated":"2017-10-31T14:12:22.177Z","comments":false,"path":"categories/index.html","permalink":"https://banghuaji.github.io/categories/index.html","excerpt":"","text":""},{"title":"customizeds","date":"2017-10-31T14:56:07.000Z","updated":"2017-10-31T15:01:42.178Z","comments":true,"path":"customizeds/index.html","permalink":"https://banghuaji.github.io/customizeds/index.html","excerpt":"","text":"关于我一只学习的小菜鸟，欢迎分享知识。 From JIMI QQ：516316976Email: 516316976@qq.com"},{"title":"tags","date":"2017-10-01T13:21:45.000Z","updated":"2017-10-01T13:24:28.000Z","comments":true,"path":"tags/index.html","permalink":"https://banghuaji.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"groovy基础","slug":"CI&CD/groovy语法","date":"2017-10-29T15:54:55.583Z","updated":"2017-10-31T14:58:54.937Z","comments":true,"path":"2017/10/29/CI&CD/groovy语法/","link":"","permalink":"https://banghuaji.github.io/2017/10/29/CI&CD/groovy语法/","excerpt":"","text":"安装groovy：12345wget https://dl.bintray.com/groovy/maven/apache-groovy-binary-2.4.7.zipunzip apache-groovy-binary-2.4.7.zipsudo ln -s /home/osboxes/Downloads/groovy-2.4.7/bin/groovy /usr/bin/groovygroovy -vGroovy Version: 2.4.7 JVM: 1.8.0_91 Vendor: Oracle Corporation OS: Linux 基础语法123456789101112131415161718192021#!/usr/bin/env groovy // Hello Worldprintln &quot;Hello world!&quot; // Variables: You can assign values to variables for later usedef x = 1println x x = new java.util.Date()println x x = -3.1499392println x x = falseprintln x x = &quot;Groovy!&quot;println x 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178//Creating an empty listdef technologies = [] /*** Adding a elements to the list ***/// As with Javatechnologies.add(&quot;Grails&quot;) // Left shift adds, and returns the listtechnologies &lt;&lt; &quot;Groovy&quot; // Add multiple elementstechnologies.addAll([&quot;Gradle&quot;,&quot;Griffon&quot;]) /*** Removing elements from the list ***/// As with Javatechnologies.remove(&quot;Griffon&quot;) // Subtraction works alsotechnologies = technologies - &apos;Grails&apos; /*** Iterating Lists ***/// Iterate over elements of a listtechnologies.each &#123; println &quot;Technology: $it&quot;&#125;technologies.eachWithIndex &#123; it, i -&gt; println &quot;$i: $it&quot;&#125; /*** Checking List contents ***///Evaluate if a list contains element(s) (boolean)contained = technologies.contains( &apos;Groovy&apos; ) // Orcontained = &apos;Groovy&apos; in technologies // Check for multiple contentstechnologies.containsAll([&apos;Groovy&apos;,&apos;Grails&apos;]) /*** Sorting Lists ***/ // Sort a list (mutates original list)technologies.sort() // To sort without mutating original, you can do:sortedTechnologies = technologies.sort( false ) /*** Manipulating Lists ***/ //Replace all elements in the listCollections.replaceAll(technologies, &apos;Gradle&apos;, &apos;gradle&apos;) //Shuffle a listCollections.shuffle(technologies, new Random()) //Clear a listtechnologies.clear() //Creating an empty mapdef devMap = [:] //Add valuesdevMap = [&apos;name&apos;:&apos;Roberto&apos;, &apos;framework&apos;:&apos;Grails&apos;, &apos;language&apos;:&apos;Groovy&apos;]devMap.put(&apos;lastName&apos;,&apos;Perez&apos;) //Iterate over elements of a mapdevMap.each &#123; println &quot;$it.key: $it.value&quot; &#125;devMap.eachWithIndex &#123; it, i -&gt; println &quot;$i: $it&quot;&#125; //Evaluate if a map contains a keyassert devMap.containsKey(&apos;name&apos;) //Evaluate if a map contains a valueassert devMap.containsValue(&apos;Roberto&apos;) //Get the keys of a mapprintln devMap.keySet() //Get the values of a mapprintln devMap.values() //Groovy supports the usual if - else syntaxdef x1 = 3 if(x1==1) &#123; println &quot;One&quot;&#125; else if(x1==2) &#123; println &quot;Two&quot;&#125; else &#123; println &quot;X greater than Two&quot;&#125; //Groovy also supports the ternary operator:def y = 10def x2 = (y &gt; 1) ? &quot;worked&quot; : &quot;failed&quot;assert x2 == &quot;worked&quot; //Instead of using the ternary operator://displayName = user.name ? user.name : &apos;Anonymous&apos;//We can write it://displayName = user.name ?: &apos;Anonymous&apos; //For loop//Iterate over a rangedef x3 = 0for (i in 0 .. 30) &#123; x3 += i&#125; //Iterate over a listx4 = 0for( i in [5,3,2,1] ) &#123; x4 += i&#125; //Iterate over an arrayarray = (0..20).toArray()x5 = 0for (i in array) &#123; x5 += i&#125; //Iterate over a mapdef map = [&apos;name&apos;:&apos;Roberto&apos;, &apos;framework&apos;:&apos;Grails&apos;, &apos;language&apos;:&apos;Groovy&apos;]x6 = 0for ( e in map ) &#123; x6 += e.value&#125; /* Closures A Groovy Closure is like a &quot;code block&quot; or a method pointer. It is a piece of code that is defined and then executed at a later point. More info at: http://www.groovy-lang.org/closures.html*/ //Example:def clos = &#123; println &quot;Hello World!&quot; &#125; println &quot;Executing the Closure:&quot;clos() //Passing parameters to a closuredef sum = &#123; a, b -&gt; println a+b &#125;sum(2,4) //Closures may refer to variables not listed in their parameter list.def x7 = 5def multiplyBy = &#123; num -&gt; num * x7 &#125;println multiplyBy(10) // If you have a Closure that takes a single argument, you may omit the// parameter definition of the Closuredef clos2 = &#123; println it &#125;clos2( &quot;hi&quot; ) /* Groovy can memoize closure results [1][2][3]*/def cl = &#123;a, b -&gt; sleep(3000) // simulate some time consuming processing a + b&#125; mem = cl.memoize() def callClosure(a, b) &#123; def start = System.currentTimeMillis() println mem(a, b) println &quot;Inputs(a = $a, b = $b) - took $&#123;System.currentTimeMillis() - start&#125; msecs.&quot;&#125; callClosure(1, 2)callClosure(1, 2)callClosure(2, 3)callClosure(2, 3)callClosure(3, 4)callClosure(3, 4)callClosure(1, 2)callClosure(2, 3)callClosure(3, 4)","categories":[],"tags":[{"name":"CI-CD","slug":"CI-CD","permalink":"https://banghuaji.github.io/tags/CI-CD/"}]},{"title":"pipeline的基础语法","slug":"CI&CD/pipeline的基础语法","date":"2017-10-29T11:28:47.096Z","updated":"2017-10-29T11:17:52.000Z","comments":true,"path":"2017/10/29/CI&CD/pipeline的基础语法/","link":"","permalink":"https://banghuaji.github.io/2017/10/29/CI&CD/pipeline的基础语法/","excerpt":"","text":"命令的执行步骤123456789101112131415Jenkinsfile (Declarative Pipeline)pipeline &#123; agent any stages &#123; stage(&apos;Build&apos;) &#123; steps &#123; sh &apos;echo &quot;Hello World&quot;&apos; sh &apos;&apos;&apos; echo &quot;Multiline shell steps works too&quot; ls -lah &apos;&apos;&apos; &#125; &#125; &#125;&#125; 重试与超时1234567891011121314151617Jenkinsfile (Declarative Pipeline)pipeline &#123; agent any stages &#123; stage(&apos;Deploy&apos;) &#123; steps &#123; retry(3) &#123; sh &apos;./flakey-deploy.sh&apos; &#125; timeout(time: 3, unit: &apos;MINUTES&apos;) &#123; sh &apos;./health-check.sh&apos; &#125; &#125; &#125; &#125;&#125; 123456789101112131415Jenkinsfile (Declarative Pipeline)pipeline &#123; agent any stages &#123; stage(&apos;Deploy&apos;) &#123; steps &#123; timeout(time: 3, unit: &apos;MINUTES&apos;) &#123; retry(5) &#123; sh &apos;./flakey-deploy.sh&apos; &#125; &#125; &#125; &#125; &#125;&#125; 完成1234567891011121314151617181920212223242526272829Jenkinsfile (Declarative Pipeline)pipeline &#123; agent any stages &#123; stage(&apos;Test&apos;) &#123; steps &#123; sh &apos;echo &quot;Fail!&quot;; exit 1&apos; &#125; &#125; &#125; post &#123; always &#123; echo &apos;This will always run&apos; &#125; success &#123; echo &apos;This will run only if successful&apos; &#125; failure &#123; echo &apos;This will run only if failed&apos; &#125; unstable &#123; echo &apos;This will run only if the run was marked as unstable&apos; &#125; changed &#123; echo &apos;This will run only if the state of the Pipeline has changed&apos; echo &apos;For example, if the Pipeline was previously failing but is now successful&apos; &#125; &#125;&#125; 12345678post &#123; always &#123; echo &apos;This will always run&apos; mail to: &apos;YYYY@yoho.cn&apos;, subject: &quot;Failed Pipeline: $&#123;currentBuild.fullDisplayName&#125; ,&amp;&amp; state is $&#123;currentBuild.currentResult&#125;&quot;, body: &quot;Something is wrong with $&#123;env.BUILD_URL&#125;&quot; &#125;&#125; 要求人力投入进行1234567891011121314151617181920212223242526Jenkinsfile (Declarative Pipeline)pipeline &#123; agent any stages &#123; /* &quot;Build&quot; and &quot;Test&quot; stages omitted */ stage(&apos;Deploy - Staging&apos;) &#123; steps &#123; sh &apos;./deploy staging&apos; sh &apos;./run-smoke-tests&apos; &#125; &#125; stage(&apos;Sanity check&apos;) &#123; steps &#123; input &quot;Does the staging environment look ok?&quot; &#125; &#125; stage(&apos;Deploy - Production&apos;) &#123; steps &#123; sh &apos;./deploy production&apos; &#125; &#125; &#125;&#125; 在Pipeline示例的这个阶段，“构建”和“测试”阶段都已成功执行。实际上，“部署”阶段只能在上一阶段成功完成，否则Pipeline将早退。1234567891011121314151617Jenkinsfile (Declarative Pipeline)pipeline &#123; agent any stages &#123; stage(&apos;Deploy&apos;) &#123; when &#123; expression &#123; currentBuild.result == null || currentBuild.result == &apos;SUCCESS&apos; &#125; &#125; steps &#123; sh &apos;make publish&apos; &#125; &#125; &#125;&#125; parallel来使得任务并行地执行1234567891011121314151617181920stage(&apos;test&apos;) &#123; steps &#123; script &#123; parallel ( aaa : &#123; build_if_needed(&apos;aaa&apos;)&#125;, bbb : &#123; build_if_needed(&apos;bbb&apos;)&#125;, ccc : &#123; build_if_needed(&apos;ccc&apos;)&#125;, ddd : &#123; build_if_needed(&apos;ddd&apos;)&#125;, eee : &#123; build_if_needed(&apos;eee&apos;)&#125; ) parallel ( fff : &#123; build_if_needed(&apos;fff&apos;)&#125;, ggg : &#123; build_if_needed(&apos;ggg&apos;)&#125;, hhh : &#123; build_if_needed(&apos;hhh&apos;)&#125;, jjj : &#123; build_if_needed(&apos;jjj&apos;)&#125;, kkk : &#123; build_if_needed(&apos;kkk&apos;)&#125; ) &#125; &#125;&#125; 12345678910111213stage(&apos;test&apos;) &#123; steps &#123; //echo &quot;steps parallel begin&quot; parallel ( aaa : &#123; build_if_needed(&apos;aaa&apos;)&#125;, bbb : &#123; build_if_needed(&apos;bbb&apos;)&#125;, ccc : &#123; build_if_needed(&apos;ccc&apos;)&#125;, ddd : &#123; build_if_needed(&apos;ddd&apos;)&#125;, eee : &#123; build_if_needed(&apos;eee&apos;)&#125; ) //echo &quot;steps parallel end&quot; &#125;&#125; 1234567891011stage(&apos;test&apos;) &#123; steps &#123; //echo &quot;steps parallel begin&quot; parallel firstBranch: &#123; echo &quot;*********** Starting Test&quot; &#125;, secondBranch: &#123; echo &quot;*********** Starting Test2&quot; &#125; //echo &quot;steps parallel end&quot; &#125;&#125; PS:注释采用// 这里面只能有一个step，否则不能够成功 选择对应的环境：12345parallel &apos;integration-tests&apos;:&#123; node(&apos;mvn-3.3&apos;)&#123; ... &#125;&#125;, &apos;functional-tests&apos;:&#123; node(&apos;selenium&apos;)&#123; ... &#125;&#125;","categories":[],"tags":[{"name":"CI-CD","slug":"CI-CD","permalink":"https://banghuaji.github.io/tags/CI-CD/"}]},{"title":"自动化目的以及答疑","slug":"autotest/自动化目的以及答疑","date":"2017-10-08T14:20:13.294Z","updated":"2017-10-08T14:20:05.000Z","comments":true,"path":"2017/10/08/autotest/自动化目的以及答疑/","link":"","permalink":"https://banghuaji.github.io/2017/10/08/autotest/自动化目的以及答疑/","excerpt":"","text":"自动化的目的 把测试从枯燥的重复劳动中解放出来，例如：回归测试等； 协助手工测试完成很难模拟或无法模拟的的工作，例如：篡改服务返回的数据验证前端对各种数据场景的处理，弱网模拟、特殊协议数据包解析验证等； 尽早发现Bug，例如：数据层的存储过程、Package批量调用验证、接口自动化等偏底层的问题； 协助定位问题，现在的自动化提出了更高的要求，例如：接口层发现问题了，可以通过添加的traceID定位到日志错误或错误代码行，app运行中异常可捕获错误日志等； 线上监控报警，现在的自动化不仅限于线下，线上的也已覆盖，测试和运维的工作可能存在交集，我们不能把质量问题寄托于他人，一旦发现问题，立即报警通知到人，让损失到最小。 提高工作效率，这个面有点广，例如，测试环境的自动化编译、打包、部署、持续集成甚至持续交付等。 关于自动化介入的若干问题 是否要考虑成本？ 当然要考虑，我们总会遇到在成本和质量之间找平衡点，可能一些特殊的行业，特殊的项目，质量的权重更高点，如果引入自动化能提高质量，该介入的还是要介入。 是不是只有大公司能做， 小公司和初创公司就不适合搞自动化？这不是绝对的，还是要看公司的资源和人员配备，如果有能力做为什么不？况且小公司的自动化不一定要做到大公司的程度，只要能提高工作效率，提高质量就可以，滴水穿石，聚沙成塔。 自动化何时介入？ 条件许可的还是尽早介入，越是底层的Bug，影响面越广，修复成本也是最低的。但这不是硬性标准，一般公司都是从UI自动化开始积累经验的，拔苗不能助长。 如何开展自动化工作这个信息量比较大，人才和技术就不多说了，我更关心的是做事的方式 抓住业务测试工作中的痛点和领导的痛点，多沟通多交流，优先解决基层的工作痛点，我相信一个好的领导会看到你的责任心和付出； 技术选型和方案可行性调研，多投入时间和精力，有的人性子急，前期做的很快，如果一开始的方向错了，最终会得不偿失； 如果是比较复杂的解决方案，尽量前后端分离、保证各模块的独立性、可融合性、解耦不解体，做到灵活可扩展，要有下一盘大棋的准备。 大家的看法每个公司的所谓的管理层对自动化理解的层面可能不一样，需要根据实际情况来做自动化，至少中心点不能偏离，需要紧扣业务，另外就是要能实际落地，还有一个就是维护成本及投入产出比。 是否要考虑成本？ 当然要考虑，我们总会遇到在成本和质量之间找平衡点，可能一些特殊的行业，特殊的项目，质量的权重更高点，如果引入自动化能提高质量，该介入的还是要介入。抓住业务测试工作中的痛点和领导的痛点，多沟通多交流，优先解决基层的工作痛点，我相信一个好的领导会看到你的责任心和付出 个人的提问看到题主关于自动化的分享， 有几个延伸问题，自己在工作中一直思考，但是一直没有找到合适的答案。 接口自动化和UI自动化的用例是完全重新设计，还是从业务用例中筛选？IF从业务用例中筛选的话，筛选的标准有哪些呢？（PS：接口用例中的接口参数类型的用例设计，暂不考虑）接口自动化和UI自动化，互相之间有影响吗？或者说接口覆盖的用例和UI覆盖的用例之间是否有某种关联？IF有关联，请问需要多大粒度的关联比较合适？ELIF 没关联，请问两者之间各自为战吗？（PS：这样会不会导致测试覆盖率重复呢？）如果UI层的用例Faile，是不是需要定位到对应的接口层？相反，接口层用例faile，是否需要定位到UI层，IF 以上需要，如何有效关联呢？Or 是否需要在分层测试的工程中，让他们互相成为彼此的辅助？ 个人答案：接口自动化和UI自动化的用例是完全重新设计，还是从业务用例中筛选？IF从业务用例中筛选的话，筛选的标准有哪些呢？（PS：接口用例中的接口参数类型的用例设计，暂不考虑）－－我觉得接口自动化案例要重新设计，这里涉及到分层的概念，接口层更关注对数据的验证，处理各种请求参数正交场景下返回数据的正确性，涉及到增、删、改的接口还要关注数据落地的有效性。 接口自动化和UI自动化，互相之间有影响吗？或者说接口覆盖的用例和UI覆盖的用例之间是否有某种关联？IF有关联，请问需要多大粒度的关联比较合适？ELIF 没关联，请问两者之间各自为战吗？（PS：这样会不会导致测试覆盖率重复呢？）－－接口测试不一定和UI测试有关联，传统的接口测试，不需要等UI开发完成就可以介入了，从这点来说属于前置阶段的，通过Mock Client实现的接口测试；－－UI测试和接口测试一定有关联，因为UI层的数据渲染大部分是通过调用接口获取的，在执行UI自动化的同时，有很多眼睛看不到摸不着的接口在来回穿梭，这些不是Mock Client发起的，而是由真实的程序发起的，场景化内部的参数动态关联等一系列问题，程序都会帮你自动处理。所以由UI测试发起的接口测试，只要你能劫持到接口返回的报文，实现起来比传统的要简单多了。 如果UI层的用例Faile，是不是需要定位到对应的接口层？相反，接口层用例faile，是否需要定位到UI层，IF 以上需要，如何有效关联呢？Or 是否需要在分层测试的工程中，让他们互相成为彼此的辅助？－－UI层Fail，接口层不一定Fail，因为即便接口是正确的，也不能保证UI层的数据再处理不会犯错。相反，接口层Fail了，与之相关的UI层必定Fail。如果接口层Fail，我们可以通过一些手段，例如：获取接口关键字、定制traceID，通过这些唯一性标识去定位错误日志或代码行。 转载于Test-Home:quqing","categories":[],"tags":[{"name":"autotest","slug":"autotest","permalink":"https://banghuaji.github.io/tags/autotest/"}]},{"title":"jquery select2使用js赋值","slug":"develop/WEB/jquery select2使用js赋值","date":"2017-10-01T13:12:22.089Z","updated":"2017-10-01T13:12:21.000Z","comments":true,"path":"2017/10/01/develop/WEB/jquery select2使用js赋值/","link":"","permalink":"https://banghuaji.github.io/2017/10/01/develop/WEB/jquery select2使用js赋值/","excerpt":"","text":"但是遇到一个问题 jquery select2插件 取值和原来的select标签取值都一样。但是给jquery select2赋值就出现了问题，用传统的select赋值的方式给jquery select2赋值发现不起作用。 最后查看了jquery select2的api文档，也网上搜了很多资料，但是都给得jquery select2赋值方式是：$(“#id”).val(“1”).trigger(“change”); 我感觉这种赋值方式是有问题，虽然这样赋值也行，但我个人不推荐这样赋值，而是使用jquery select2 api 里提到的赋值方式：$(“#id”).val(“1”).select2(); 这样就可以了。","categories":[],"tags":[{"name":"WEB","slug":"WEB","permalink":"https://banghuaji.github.io/tags/WEB/"}]},{"title":"git安装与使用","slug":"SOFT/GIT/git安装与使用","date":"2017-10-01T12:45:15.343Z","updated":"2017-05-26T01:39:38.000Z","comments":true,"path":"2017/10/01/SOFT/GIT/git安装与使用/","link":"","permalink":"https://banghuaji.github.io/2017/10/01/SOFT/GIT/git安装与使用/","excerpt":"","text":"一、安装Git（windows版、其他平台参阅） 去Git的官网，下载安装包，安装时，一路默认https://git-scm.com/download/win 二、配置Git 2.1 在任意地方，创建一个文件夹，保证该文件夹的目录全部是英文 2.2 打开新建的文件夹，在空白处右击，菜单中点选 Git Init Here 2.3 再次右击，菜单中点选Git Bash，弹出命令行 2.4 配置所有本地仓的账号、邮箱 12$ git config --global user.name \"Your Name\" $ git config --global user.email \"email@example.com\" 2.5 为避免每次远程访问输入密码，使用ssh登陆。ssh应该是与本机信息绑定的，所以每台电脑需要单独生成。 1$ ssh-keygen -t rsa -C \"youremail@example.com\" 2.6 ssh只是本地详细，需要在GitLab中备份，才能被验证。打开自己的GitLab，在My Profile中，点击Add Public Key，title随意。 2.7 key中的内容在本机C盘中，C:\\Users\\account（你的账户下），里面有个.ssh文件夹（运行2.5会产生），用文本文档打开id_rsa.pub，将里面的内容全部复制到key中，即可； 2.8 到此，基本配置完毕；我们需要获取GitLab上项目的地址，每个项目地址不同，一般在GitLab的Projects中，能找到跟你相关的所有项目，点开一个项目，就能看到项目地址，然后在Git Bash中输入： 1$ git clone git@github.com:michaelliao/gitskills.git 2.9 在克隆仓库时，Git 通常会自动创建一个名为 master 的分支来跟踪 origin/master，如果需要关联不同的分支，使用命令 1$ git checkout --track origin/br-2.1.2.1 2.10 将数据同步到本地，一般关联后，直接: 1$ git pull 即可完成项目的拉取至此，我们完成了一个在GitLab上的项目，到本地的过程。 More info: 廖雪峰的官方网站","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"https://banghuaji.github.io/tags/工具/"},{"name":"GIT","slug":"GIT","permalink":"https://banghuaji.github.io/tags/GIT/"}]},{"title":"LINUX实现免密钥登陆","slug":"SOFT/GIT/LINUX实现免密钥登陆","date":"2017-10-01T12:45:15.297Z","updated":"2017-05-25T07:31:25.000Z","comments":true,"path":"2017/10/01/SOFT/GIT/LINUX实现免密钥登陆/","link":"","permalink":"https://banghuaji.github.io/2017/10/01/SOFT/GIT/LINUX实现免密钥登陆/","excerpt":"","text":"github 或者gitlab 设置添加SSH, 避免每次提交重复输入用户名克隆项目二种方式： 使用https url克隆, 复制https url 然后到 git clone https-url 使用 SSH url克隆却需要在克隆之前先配置和添加好 SSH key, 你必须是这个项目的拥有者。否则你是无法添加 SSH key 的。 https 和 SSH 的区别：1、前者可以随意克隆github上的项目，而不管是谁的；而后者则是你必须是你要克隆的项目的拥有者或管理员，且需要先添加 SSH key ，否则无法克隆。 2、https url 在push的时候是需要验证用户名和密码的；而 SSH 在push的时候，是不需要输入用户名的，如果配置SSH key的时候设置了密码，则需要输入密码的，否则直接是不需要输入密码的。 在 github 上添加 SSH key 的步骤：1、首先需要检查你电脑是否已经有 SSH key 运行 git Bash 客户端，输入如下代码： 12$ cd ~/.ssh$ ls 这两个命令就是检查是否已经存在 id_rsa.pub 或 id_dsa.pub 文件，如果文件已经存在，那么你可以跳过步骤2，直接进入步骤3。 2、创建一个 SSH key 1$ ssh-keygen -t rsa -C \"your_email@example.com\" 代码参数含义： -t 指定密钥类型，默认是 rsa ，可以省略。-C 设置注释文字，比如邮箱。-f 指定密钥文件存储文件名。 以上代码省略了 -f 参数，因此，运行上面那条命令后会让你输入一个文件名，用于保存刚才生成的 SSH key 代码，如： Generating public/private rsa key pair. Enter file in which to save the key (/c/Users/you/.ssh/id_rsa): [Press enter]当然，你也可以不输入文件名，使用默认文件名（推荐），那么就会生成 id_rsa 和 id_rsa.pub 两个秘钥文件。 接着又会提示你输入两次密码（该密码是你push文件的时候要输入的密码，而不是github管理者的密码）， 当然，你也可以不输入密码，直接按回车。那么push的时候就不需要输入密码，直接提交到github上了，如： Enter passphrase (empty for no passphrase): Enter same passphrase again:接下来，就会显示如下代码提示，如： 1234Your identification has been saved in /c/Users/you/.ssh/id_rsa.# Your public key has been saved in /c/Users/you/.ssh/id_rsa.pub.# The key fingerprint is:# 01:0f:f4:3b:ca:85:d6:17:a1:7d:f0:68:9d:f0:a2:db your_email@example.com 当你看到上面这段代码的收，那就说明，你的 SSH key 已经创建成功，你只需要添加到github的SSH key上就可以了。 3、添加你的 SSH key 到 github上面去 a、首先你需要拷贝 id_rsa.pub 文件的内容，你可以用编辑器打开文件复制，也可以用git命令复制该文件的内容，如： $ clip &lt; ~/.ssh/id_rsa.pubb、登录你的github账号，从又上角的设置（ Account Settings ）进入，然后点击菜单栏的 SSH key 进入页面添加 SSH key。 c、点击 Add SSH key 按钮添加一个 SSH key 。把你复制的 SSH key 代码粘贴到 key 所对应的输入框中，记得 SSH key 代码的前后不要留有空格或者回车。当然，上面的 Title 所对应的输入框你也可以输入一个该 SSH key 显示在 github 上的一个别名。默认的会使用你的邮件名称。 4、测试一下该SSH key 在git Bash 中输入以下代码 $ ssh -T git@github.com当你输入以上代码时，会有一段警告代码，如： The authenticity of host ‘github.com (207.97.227.239)’ can’t be established. RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48. Are you sure you want to continue connecting (yes/no)?这是正常的，你输入 yes 回车既可。如果你创建 SSH key 的时候设置了密码，接下来就会提示你输入密码，如： Enter passphrase for key ‘/c/Users/Administrator/.ssh/id_rsa’:当然如果你密码输错了，会再要求你输入，知道对了为止。 注意：输入密码时如果输错一个字就会不正确，使用删除键是无法更正的。 密码正确后你会看到下面这段话，如： Hi username! You’ve successfully authenticated, but GitHub does not provide shell access.如果用户名是正确的,你已经成功设置SSH密钥。如果你看到 “access denied” ，者表示拒绝访问，那么你就需要使用 https 去访问，而不是 SSH 。","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"https://banghuaji.github.io/tags/工具/"},{"name":"GIT","slug":"GIT","permalink":"https://banghuaji.github.io/tags/GIT/"}]},{"title":"Docker安装与调试","slug":"docker/Docker(一)--安装","date":"2017-10-01T12:45:15.270Z","updated":"2017-06-13T02:58:32.000Z","comments":true,"path":"2017/10/01/docker/Docker(一)--安装/","link":"","permalink":"https://banghuaji.github.io/2017/10/01/docker/Docker(一)--安装/","excerpt":"","text":"linux—centos下面安装docker的官方安装文档：由docker给的文档可以看出它也只是去配置了一个docker的yum源、然后就通过这个源来安装docker了；在这个文档下我们采用手工配置 1https://docs.docker.com/engine/installation/linux/centos/ 必备条件1、LINUX centos 7以上可以通过1uname -r 1234567lsb_release -a[root@localhost docker]# lsb_release -aLSB Version: :core-4.1-amd64:core-4.1-noarchDistributor ID: CentOSDescription: CentOS Linux release 7.2.1511 (Core) Release: 7.2.1511Codename: Core 配置一个docker用的源：1、为docker 增加一个新的yum配置文件；1touch /etc/yum.repos.d/docker.repo 2、docker.repo的内容如下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162[docker-ce-stable]name=Docker CE Stable - $basearchbaseurl=https://download.docker.com/linux/centos/7/$basearch/stableenabled=1gpgcheck=0 #我把这里设置成了0、说明我信任了这个源，不对它的rpm进行检察gpgkey=https://download.docker.com/linux/centos/gpg[docker-ce-stable-debuginfo]name=Docker CE Stable - Debuginfo $basearchbaseurl=https://download.docker.com/linux/centos/7/debug-$basearch/stableenabled=0gpgcheck=1gpgkey=https://download.docker.com/linux/centos/gpg[docker-ce-stable-source]name=Docker CE Stable - Sourcesbaseurl=https://download.docker.com/linux/centos/7/source/stableenabled=0gpgcheck=1gpgkey=https://download.docker.com/linux/centos/gpg[docker-ce-edge]name=Docker CE Edge - $basearchbaseurl=https://download.docker.com/linux/centos/7/$basearch/edgeenabled=0gpgcheck=1gpgkey=https://download.docker.com/linux/centos/gpg[docker-ce-edge-debuginfo]name=Docker CE Edge - Debuginfo $basearchbaseurl=https://download.docker.com/linux/centos/7/debug-$basearch/edgeenabled=0gpgcheck=1gpgkey=https://download.docker.com/linux/centos/gpg[docker-ce-edge-source]name=Docker CE Edge - Sourcesbaseurl=https://download.docker.com/linux/centos/7/source/edgeenabled=0gpgcheck=1gpgkey=https://download.docker.com/linux/centos/gpg[docker-ce-test]name=Docker CE Test - $basearchbaseurl=https://download.docker.com/linux/centos/7/$basearch/testenabled=0gpgcheck=1gpgkey=https://download.docker.com/linux/centos/gpg[docker-ce-test-debuginfo]name=Docker CE Test - Debuginfo $basearchbaseurl=https://download.docker.com/linux/centos/7/debug-$basearch/testenabled=0gpgcheck=1gpgkey=https://download.docker.com/linux/centos/gpg[docker-ce-test-source]name=Docker CE Test - Sourcesbaseurl=https://download.docker.com/linux/centos/7/source/testenabled=0gpgcheck=1gpgkey=https://download.docker.com/linux/centos/gpg 安装docker:12345678910111213141516171819202122232425262728sudo yum install docker-ceLoaded plugins: fastestmirror, langpacksLoading mirror speeds from cached hostfileResolving Dependencies--&gt; Running transaction check---&gt; Package docker-ce.x86_64 0:17.03.1.ce-1.el7.centos will be installed--&gt; Processing Dependency: docker-ce-selinux &gt;= 17.03.1.ce-1.el7.centos for package: docker-ce-17.03.1.ce-1.el7.centos.x86_64--&gt; Running transaction check---&gt; Package docker-ce-selinux.noarch 0:17.03.1.ce-1.el7.centos will be installed--&gt; Finished Dependency ResolutionDependencies Resolved===================================================================================================================================== Package Arch Version Repository Size=====================================================================================================================================Installing: docker-ce x86_64 17.03.1.ce-1.el7.centos docker-ce-stable 19 MInstalling for dependencies: docker-ce-selinux noarch 17.03.1.ce-1.el7.centos docker-ce-stable 28 kTransaction Summary=====================================================================================================================================Install 1 Package (+1 Dependent package)Total download size: 19 MInstalled size: 19 MIs this ok [y/d/N]: y 直接下载rpm包的方式来安装1、我在安装docker的时候发现下载的速度只有3kB/s 然而文件大小有19M；就在我感觉安装无望的时候、我机智的想到了自己直接把rpm下载下来 看了下docker.repo 、发现centos7的源地址是 https://download.docker.com/linux/centos/7/$basearch/stable 所以我只要去1https://download.docker.com/linux/centos/7/x86_64/stable/Packages/ 下载的文件需要注意的版本12docker-ce-17.03.0.ce-1.el7.centos.x86_64.rpm docker-ce-selinux-17.03.0.ce-1.el7.centos.noarch.rpm 安装docker123456789101112131415161718192021222324252627282930313233343536373839404142434445464748lltotal 19096-rwxrwxrwx 1 jianglexing jianglexing 19521288 May 30 20:05 docker-ce-17.03.0.ce-1.el7.centos.x86_64.rpm-rw-r--r-- 1 jianglexing jianglexing 29108 May 30 20:15 docker-ce-selinux-17.03.0.ce-1.el7.centos.noarch.rpm[root@workstudio docker]# yum localinstall *Loaded plugins: fastestmirror, langpacksExamining docker-ce-17.03.0.ce-1.el7.centos.x86_64.rpm: docker-ce-17.03.0.ce-1.el7.centos.x86_64Marking docker-ce-17.03.0.ce-1.el7.centos.x86_64.rpm to be installedExamining docker-ce-selinux-17.03.0.ce-1.el7.centos.noarch.rpm: docker-ce-selinux-17.03.0.ce-1.el7.centos.noarchMarking docker-ce-selinux-17.03.0.ce-1.el7.centos.noarch.rpm to be installedResolving Dependencies--&gt; Running transaction check---&gt; Package docker-ce.x86_64 0:17.03.0.ce-1.el7.centos will be installed---&gt; Package docker-ce-selinux.noarch 0:17.03.0.ce-1.el7.centos will be installed--&gt; Finished Dependency ResolutionDependencies Resolved===================================================================================================================================== Package Arch Version Repository Size=====================================================================================================================================Installing: docker-ce x86_64 17.03.0.ce-1.el7.centos /docker-ce-17.03.0.ce-1.el7.centos.x86_64 65 M docker-ce-selinux noarch 17.03.0.ce-1.el7.centos /docker-ce-selinux-17.03.0.ce-1.el7.centos.noarch 43 kTransaction Summary=====================================================================================================================================Install 2 PackagesTotal size: 65 MInstalled size: 65 MIs this ok [y/d/N]: yDownloading packages:Running transaction checkRunning transaction testTransaction test succeededRunning transaction Installing : docker-ce-selinux-17.03.0.ce-1.el7.centos.noarch 1/2 setsebool: SELinux is disabled.libsemanage.semanage_direct_install_info: Overriding docker module at lower priority 100 with module at priority 400. Installing : docker-ce-17.03.0.ce-1.el7.centos.x86_64 2/2 Verifying : docker-ce-17.03.0.ce-1.el7.centos.x86_64 1/2 Verifying : docker-ce-selinux-17.03.0.ce-1.el7.centos.noarch 2/2 Installed: docker-ce.x86_64 0:17.03.0.ce-1.el7.centos docker-ce-selinux.noarch 0:17.03.0.ce-1.el7.centos Complete! 启动DOCKER12345[root@workstudio docker]# systemctl start docker[root@workstudio docker]# ps -ef | grep dockerroot 4458 1 1 20:22 ? 00:00:00 /usr/bin/dockerdroot 4465 4458 0 20:22 ? 00:00:00 docker-containerd -l unix:///var/run/docker/libcontainerd/docker-containerd.sock --metrics-interval=0 --start-timeout 2m --state-dir /var/run/docker/libcontainerd/containerd --shim docker-containerd-shim --runtime docker-runcroot 4589 4333 0 20:22 pts/1 00:00:00 grep --color=auto docker 测试docker是否能成功运行有可能遇到无法下载的问题：需要多试几次，123Unable to find image &apos;hello-world:latest&apos; locallydocker: Error response from daemon: Get https://registry-1.docker.io/v2/: dial tcp: lookup registry-1.docker.io on 223.5.5.5:53: read udp 192.168.103.71:56024-&gt;223.5.5.5:53: i/o timeout.See &apos;docker run --help&apos;. 正确展示 1234567891011121314151617181920212223242526[root@workstudio docker]# docker run hello-worldUnable to find image &apos;hello-world:latest&apos; locallylatest: Pulling from library/hello-world78445dd45222: Pull complete Digest: sha256:c5515758d4c5e1e838e9cd307f6c6a0d620b5e07e6f927b07d05f6d12a1ac8d7Status: Downloaded newer image for hello-world:latestHello from Docker!This message shows that your installation appears to be working correctly.To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub. 3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal.To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bashShare images, automate workflows, and more with a free Docker ID: https://cloud.docker.com/For more examples and ideas, visit: https://docs.docker.com/engine/userguide/","categories":[],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://banghuaji.github.io/tags/Docker/"}]},{"title":"JAVA基础知识","slug":"JAVA/JAVA基础篇","date":"2017-10-01T12:45:15.113Z","updated":"2017-10-31T14:13:44.137Z","comments":true,"path":"2017/10/01/JAVA/JAVA基础篇/","link":"","permalink":"https://banghuaji.github.io/2017/10/01/JAVA/JAVA基础篇/","excerpt":"","text":"==符的使用1234Integer a = 1000,b=1000; Integer c = 100,d=100; System.out.println(a==b); //falseSystem.out.println(c==d); //true 查看其中原理 首先公布下答案， 运行代码，我们会得到 false true。我们知道==比较的是两个对象的引用，这里的abcd都是新建出来的对象，按理说都应该输入false才对。这就是这道题的有趣之处，无论是面试题还是论坛讨论区，这道题的出场率都很高。原理其实很简单，我们去看下Integer.Java这个类就了然了。 1234567891011121314public static Integer valueOf(int i) &#123; return i &gt;= 128 || i &lt; -128 ? new Integer(i) : SMALL_VALUES[i + 128]; &#125; /** * A cache of instances used by &#123;@link Integer#valueOf(int)&#125; and auto-boxing */ private static final Integer[] SMALL_VALUES = new Integer[256]; static &#123; for (int i = -128; i &lt; 128; i++) &#123; SMALL_VALUES[i + 128] = new Integer(i); &#125; &#125; 当我们声明一个Integer c = 100;的时候。此时会进行自动装箱操作，简单点说，也就是把基本数据类型转换成Integer对象，而转换成Integer对象正是调用的valueOf方法，可以看到，Integer中把-128-127 缓存了下来。官方解释是小的数字使用的频率比较高，所以为了优化性能，把这之间的数缓存了下来。这就是为什么这道题的答案回事false和ture了。当声明的Integer对象的值在-128-127之间的时候，引用的是同一个对象，所以结果是true。 123456Integer a = new Integer(1000); int b = 1000; Integer c = new Integer(10); Integer d = new Integer(10); System.out.println(a == b); System.out.println(c == d); 正确答案： true 、false 看到这个答案很多小伙伴又会不解，先来说下第二个，按第一题来说Integer不是把-128-127缓存起来了吗？这不是应该是true嘛，但是你仔细看，这里的Integer是我们自己new出来的，并不是用的缓存，所以结果是false。 现在来看第一个为啥又是true了呢？ 首先这里的值为1000，肯定和我们所知的Integer缓存没有关系。既然和缓存没有关系，a是新new出来的对象，按理说输入应该是false才对。但是注意b这里是int类型。当int和Integer进行==比较的时候，Java会把Integer进行自动拆箱，也就是把Integer转成int类型，所以这里进行比较的是int类型的值，所以结果即为true。 String12345String s1 = &quot;abc&quot;; String s2 = &quot;abc&quot;; String s3 = new String(&quot;abc&quot;); System.out.println(s1 == s2); System.out.println(s1 == s3); 按照==的语法来看， 首先s1、s2、s3是三个不同的对象，常理来说，输出都会是false。然而程序的运行结果确实true、false。第二个输出false可以理解，第一个输出true就又让人费解了。我们知道一些基本类型的变量和对象的引用变量都是在函数的栈内存中分配，而堆内存中则存放new 出来的对象和数组。然而除此之外还有一块区域叫做常量池。像我们通常想String s1 = “abc”; 这样申明的字符串对象，其值就是存储在常量池中。当我们创建String s1 = “abc”这样一个对象之后，”abc”就存储到了常量池（也可叫做字符串池）中，当我们创建引用String s2 = “abc” 的时候，Java底层会优先在常量池中查找是否存在”abc”，如果存在则让s2指向这个值，不会重新创建，如果常量池中没有则创建并添加的池中。这就是为什么答案是true 和false的原因。 final关键字1234567891011121314public void mRun(final String name)&#123; new Runnable() &#123; public void run() &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; System.out.println(name); &#125; &#125;.start(); &#125; 这种代码相信大家写过很多，当内部类访问局部变量的时候，需要在局部变量前加final修饰符，不然编译器就会报错。通常我们也是这么干的。好的，第二个问题来了，为什么要加final修饰符？相信大多数小伙伴都没有思考过这个问题，但凡使用的时候，直接加上就得了，从来没去深究过其中的原理。这对于一个优秀的程序员来说是不可取，我们不仅要知其然还要知其所以然。 现在我们来分析一下，为什么要加final关键字。首先内部类的生命周期是成员级别的，而局部变量的生命周期实在方法体之类。也就是说会出现这样一种情况，当mRun方法执行，new 的线程运行，新线程里面会睡一秒。主线程会继续执行，mRun执行完毕，name属性生命周期结束。1秒之后，Syetem.out.printh(name)执行。然而此时name已经寿终正寝，不在内存中了。Java就是为了杜绝这种错误，严格要求内部类中方位局部变量，必须使用final关键字修饰。局部变量被final修饰之后，此时会在内存中保有一份局部变得的复制品，当内部类访问的时候其实访问的是这个复制品。这就好像是把局部变量的生命周期变长了。说到底还是Java工程师提前把这个坑给我们填了，不然不知道又会有多少小伙伴会为了内部类局部变量而发愁了。","categories":[{"name":"Java","slug":"Java","permalink":"https://banghuaji.github.io/categories/Java/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://banghuaji.github.io/tags/JAVA/"}]},{"title":"异步调用线程","slug":"JAVA/异步调用","date":"2017-10-01T12:45:14.872Z","updated":"2017-06-08T04:33:39.000Z","comments":true,"path":"2017/10/01/JAVA/异步调用/","link":"","permalink":"https://banghuaji.github.io/2017/10/01/JAVA/异步调用/","excerpt":"","text":"之前的同事给的一个例子 123456789101112131415161718192021222324252627282930313233343536373839404142import java.util.concurrent.Callable;import java.util.concurrent.CompletableFuture;import java.util.function.Consumer;public class CallbackDemo &#123; public static void main(String[] args) throws InterruptedException &#123; // 异步调用运程方法，结束后数据写入数据库 asyncCall(new Callable&lt;String&gt;() &#123; // &lt;- 这个是请求方法 @Override public String call() throws Exception &#123; // TODO 向远程发送请求 return \"请求结果\"; &#125; &#125;, new Consumer&lt;String&gt;() &#123; // &lt;- 这个是回调方法 @Override public void accept(String s) &#123; System.out.println(s + \"写入数据库\"); &#125; &#125;); Thread.sleep(1000l); &#125; private static &lt;T&gt; void asyncCall(Callable&lt;T&gt; callable, Consumer&lt;T&gt; callback) &#123; CompletableFuture.runAsync(new Runnable() &#123; @Override public void run() &#123; // TODO 远程调用获取结果 result try &#123; T result = callable.call(); callback.accept(result); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;); &#125;&#125;","categories":[],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://banghuaji.github.io/tags/JAVA/"},{"name":"JAVA基础","slug":"JAVA基础","permalink":"https://banghuaji.github.io/tags/JAVA基础/"}]},{"title":"冒泡的排序","slug":"JAVA/冒泡排序","date":"2017-10-01T12:45:14.854Z","updated":"2017-06-04T15:33:55.000Z","comments":true,"path":"2017/10/01/JAVA/冒泡排序/","link":"","permalink":"https://banghuaji.github.io/2017/10/01/JAVA/冒泡排序/","excerpt":"","text":"冒泡的排序1234567891011121314151617181920212223public class BubbleSort&#123; public static void main(String[] args)&#123; int score[] = &#123;67, 69, 75, 87, 89, 90, 99, 100&#125;; for (int i = 0; i &lt; score.length -1; i++)&#123; //最多做n-1趟排序 for(int j = 0 ;j &lt; score.length - i - 1; j++)&#123; //对当前无序区间score[0......length-i-1]进行排序(j的范围很关键，这个范围是在逐步缩小的) if(score[j] &lt; score[j + 1])&#123; //把小的值交换到后面 int temp = score[j]; score[j] = score[j + 1]; score[j + 1] = temp; &#125; &#125; System.out.print(\"第\" + (i + 1) + \"次排序结果：\"); for(int a = 0; a &lt; score.length; a++)&#123; System.out.print(score[a] + \"\\t\"); &#125; System.out.println(\"\"); &#125; System.out.print(\"最终排序结果：\"); for(int a = 0; a &lt; score.length; a++)&#123; System.out.print(score[a] + \"\\t\"); &#125; &#125; &#125;","categories":[],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://banghuaji.github.io/tags/JAVA/"}]},{"title":"测试现状","slug":"caprice/测试的现状","date":"2017-10-01T12:45:14.836Z","updated":"2017-06-10T13:45:34.000Z","comments":true,"path":"2017/10/01/caprice/测试的现状/","link":"","permalink":"https://banghuaji.github.io/2017/10/01/caprice/测试的现状/","excerpt":"","text":"下面两个文档体现出软件测试的现状测试的主要工作：1、保证质量（本职的工作） 2、背锅？？ welcome to 51testing Testingba工作室 现在很多公司的做法很多所谓的移动互联网公司完全不注重测试，把用户当做一手的测试人员，后台收集bug数据，一周发两个版本也是家常便饭。。。","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://banghuaji.github.io/tags/随笔/"}]},{"title":"高级测试工程师技术基础","slug":"caprice/高级测试工程师技术基础","date":"2017-10-01T12:45:14.800Z","updated":"2017-06-05T12:20:18.000Z","comments":true,"path":"2017/10/01/caprice/高级测试工程师技术基础/","link":"","permalink":"https://banghuaji.github.io/2017/10/01/caprice/高级测试工程师技术基础/","excerpt":"","text":"下面是之前测试总监整理的【高级测试工程师】所应该具备的技能：","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://banghuaji.github.io/tags/随笔/"},{"name":"职业生涯","slug":"职业生涯","permalink":"https://banghuaji.github.io/tags/职业生涯/"}]}]}