{"meta":{"title":"JIMI的博客","subtitle":"想取个能够唬住人的标题到今天也没找到","description":"努力超越那个谁","author":"JIMI","url":"https://banghuaji.github.io"},"pages":[{"title":"","date":"2017-10-01T12:38:16.285Z","updated":"2017-10-01T12:37:48.000Z","comments":true,"path":"404.html","permalink":"https://banghuaji.github.io/404.html","excerpt":"","text":""},{"title":"categories","date":"2017-10-01T13:21:45.000Z","updated":"2017-10-31T14:12:22.177Z","comments":false,"path":"categories/index.html","permalink":"https://banghuaji.github.io/categories/index.html","excerpt":"","text":""},{"title":"customizeds","date":"2017-10-31T14:56:07.000Z","updated":"2017-10-31T15:01:42.178Z","comments":true,"path":"customizeds/index.html","permalink":"https://banghuaji.github.io/customizeds/index.html","excerpt":"","text":"关于我一只学习的小菜鸟，欢迎分享知识。 From JIMI QQ：516316976Email: 516316976@qq.com"},{"title":"tags","date":"2017-10-01T13:21:45.000Z","updated":"2017-10-01T13:24:28.000Z","comments":true,"path":"tags/index.html","permalink":"https://banghuaji.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Groovy脚本基础全攻略","slug":"language/groovy/Groovy脚本基础全攻略","date":"2017-11-03T04:44:21.126Z","updated":"2017-11-03T04:42:46.674Z","comments":true,"path":"2017/11/03/language/groovy/Groovy脚本基础全攻略/","link":"","permalink":"https://banghuaji.github.io/2017/11/03/language/groovy/Groovy脚本基础全攻略/","excerpt":"","text":"背景Groovy脚本基于Java且拓展了Java，所以从某种程度来说掌握Java是学习Groovy的前提，故本文适用于不熟悉Groovy却想快速得到Groovy核心基础干货的Java开发者（注意是Java），因为我的目的不是深入学习Groovy语言，所以本文基本都是靠代码来解释，这样最直观，同时也够干货基础入门Groovy的特点和结构。 Groovy是一种动态语言，它和Java类似（算是Java的升级版，但是又具备脚本语言的特点），都在Java虚拟机中运行。当运行Groovy脚本时它会先被编译成Java类字节码，然后通过JVM虚拟机执行这个Java字节码类。 快速安装指南：我们在写Groovy代码时可以直接使用自己喜欢的文本编辑器编辑OK以后以.groovy后缀保存，然后在终端执行如下命令即可运行： 1$ groovy ./TestFile.groovy 再或者我们还可以使用Intellij IDEA等工具安装groovy插件进行groovy开发，这里不再一一叙述了（配置环境点我），直接给出一个读取指定文件内容打印的例子，如下： 语法基础注释Groovy的单行注释、多行注释、文档注释基本都和Java一样，没啥特殊的，不再细说。只有一种特殊的单行注释需要留意一下即可。如下：12#!/usr/bin/env groovyprintln &quot;Hello from the shebang line&quot; 这种注释通常是用来给UNIX系统声明允许脚本运行的类型的，一般都是固定写法，没啥讲究的。 关键字Groovy有如下一些关键字，我们些代码命名时要注意： 12as、assert、break、case、catch、class、const、continue、def、default、do、else、enum、extends、false、finally、for、goto、if、implements、import、in、instanceof、interface、new、null、package、return、super、switch、this、throw、throws、trait、true、try、while 这玩意和其他语言一样，没啥特殊的，自行脑补。 标识符对于Groovy的标示符和Java还是有些共同点和区别的，特别是引用标示符的区别，具体可以往下看。 普通标识符普通标识符定义和C语言类似，只能以字母、美元符、下划线开始，不能以数字开头。如下例子： 12345678//正确def namedef $namedef name_typedef foo.assert//错误def 5typedef a+b 引用标识符引用标识符出现在点后的表达式中，我们可以如下一样使用： 12345678def map = [:]//引用标示符中出现空格也是对的map.&quot;an identifier with a space and double quotes&quot; = &quot;ALLOWED&quot;//引用标示符中出现横线也是对的map.&apos;with-dash-signs-and-single-quotes&apos; = &quot;ALLOWED&quot;assert map.&quot;an identifier with a space and double quotes&quot; == &quot;ALLOWED&quot;assert map.&apos;with-dash-signs-and-single-quotes&apos; == &quot;ALLOWED&quot; Groovy的所有字符串都可以当作引用标示符定义，如下： 12345678910111213//如下类型字符串作为引用标识符都是对的map.&apos;single quote&apos;map.&quot;double quote&quot;map.&apos;&apos;&apos;triple single quote&apos;&apos;&apos;map.&quot;&quot;&quot;triple double quote&quot;&quot;&quot;map./slashy string/map.$/dollar slashy string/$//稍微特殊的GString，也是对的def firstname = &quot;Homer&quot;map.&quot;Simson-$&#123;firstname&#125;&quot; = &quot;Homer Simson&quot;assert map.&apos;Simson-Homer&apos; == &quot;Homer Simson 字符及字符串Groovy有java.lang.String和groovy.lang.GString两中字符串对象类型，具体如下细说。 单引号字符串单引号字符串是java.lang.String类型的，不支持站位符插值操作，譬如： 12345def name = &apos;Test Groovy!&apos;def body = &apos;Test $name&apos;assert name == &apos;Test Groovy!&apos;assert body == &apos;Test $name&apos; //不会替换$name站位符 123Groovy的字符串可以通过”+“直接拼接，譬如：assert &apos;ab&apos; == &apos;a&apos; + &apos;b&apos; 其中涉及转义字符规则同Java，只用特殊注意”’“的转义即可。 三重单引号字符串三重单引号字符串是java.lang.String类型的，不支持站位符插值操作，可以标示多行字符串，譬如： 123def aMultilineString = &apos;&apos;&apos;line oneline twoline three&apos;&apos;&apos; 三重单引号字符串允许字符串的内容在多行出现，新的行被转换为“\\n”，其他所有的空白字符都被完整的按照文本原样保留；字符开头添加“/”表示字符内容不转义反斜杠“\\”，只有在反斜杠接下来是一个字符u的时候才需要进行转义，因为\\u表示一个unicode转义。如下： 1234567def strippedFirstNewline = &apos;&apos;&apos;\\line oneline twoline three&apos;&apos;&apos;assert !strippedFirstNewline.startsWith(&apos;\\n&apos;) 双引号字符串双引号字符串支持站位插值操作，如果双引号字符串中不包含站位符则是java.lang.String类型的，如果双引号字符串中包含站位符则是groovy.lang.GString类型的。 对于插值占位符我们可以用${}或者$来标示，${}用于一般替代字串或者表达式，$主要用于A.B的形式中，具体如下例子： 123456789def name = &apos;Guillaume&apos; // a plain stringdef greeting = &quot;Hello $&#123;name&#125;&quot;assert greeting.toString() == &apos;Hello Guillaume&apos;def sum = &quot;The sum of 2 and 3 equals $&#123;2 + 3&#125;&quot;assert sum.toString() == &apos;The sum of 2 and 3 equals 5&apos;def person = [name: &apos;Guillaume&apos;, age: 36]assert &quot;$person.name is $person.age years old&quot; == &apos;Guillaume is 36 years old&apos; 特别注意，$只对A.B等有效，如果表达式包含括号（像方法调用）、大括号、闭包等符号则是无效的。譬如： 1234def number = 3.14shouldFail(MissingPropertyException) &#123; println &quot;$number.toString()&quot;&#125; //该代码运行抛出groovy.lang.MissingPropertyException异常，因为Groovy认为去寻找number的名为toString的属性，所以异常 注意，在表达式中访问属性前必须保证属性已经定义好(值为空也可以)，如果使用了未定义的属性会抛出groovy.lang.MissingPropertyException异常。 GString还支持延迟运算，譬如在GString中使用闭包，闭包在调用GString的toString()方法时被延迟执行；闭包中可以有0或1个参数，若指定一个参数，则参数会被传入一个Writer对象，我们可以利用这个Writer对象来写入字符，若没有参数，闭包返回值的toString()方法被调用。譬如： 123456//无参数闭包def sParameterLessClosure = &quot;1 + 2 == $&#123;-&gt; 3&#125;&quot; assert sParameterLessClosure == &apos;1 + 2 == 3&apos;//一个参数闭包def sOneParamClosure = &quot;1 + 2 == $&#123; w -&gt; w &lt;&lt; 3&#125;&quot; assert sOneParamClosure == &apos;1 + 2 == 3&apos; 上面了解了GString的推迟运算特性，下面我们再来看一个牛逼的特性，如下： 12345678910def number = 1 def eagerGString = &quot;value == $&#123;number&#125;&quot;def lazyGString = &quot;value == $&#123; -&gt; number &#125;&quot;assert eagerGString == &quot;value == 1&quot; assert lazyGString == &quot;value == 1&quot; number = 2 assert eagerGString == &quot;value == 1&quot; assert lazyGString == &quot;value == 2&quot; 可以看见，eagerGString是普通的双引号插值站位替换，lazyGString是双引号闭包插值替换，我们可以发现在number变为2以后他们的运算结果就有了差异。可以明显推理到结论，一个普通插值表达式值替换实际是在GString创建的时刻，一个包含闭包的表达式由于延迟运算调运toString()方法，所以会产生一个新的字符串值。 当然了，GString和String即使字符串一样他们的HashCode也不会一样，譬如： 1assert &quot;one: $&#123;1&#125;&quot;.hashCode() != &quot;one: 1&quot;.hashCode() 由于相同字符串的String与GString的HashCode不同，所以我们一定要避免使用GString作为MAP的key，譬如： 1234def key = &quot;a&quot;def m = [&quot;$&#123;key&#125;&quot;: &quot;letter $&#123;key&#125;&quot;] assert m[&quot;a&quot;] == null //由于key的HashCode不同，所以取不到 其中涉及转义字符规则同Java，只用特殊注意””“的转义即可。 多重双引号字符串多重双引号字符串也支持站位插值操作，我们要特别注意在多重双引号字符串中的单引号和双引号转换问题。譬如： 123456789101112def name = &apos;Groovy&apos;def template = &quot;&quot;&quot; Dear Mr $&#123;name&#125;, You&apos;re the winner of the lottery! Yours sincerly, Dave&quot;&quot;&quot;assert template.toString().contains(&apos;Groovy&apos;) 斜线字符串斜线字符串其实和双引号字符串很类似，通常用在正则表达式中，下面我们看几个例子，如下： 1234567891011121314151617//普通使用def fooPattern = /.*foo.*/assert fooPattern == &apos;.*foo.*&apos;//含转义字符使用def escapeSlash = /The character \\/ is a forward slash/assert escapeSlash == &apos;The character / is a forward slash&apos;//多行支持def multilineSlashy = /one two three/assert multilineSlashy.contains(&apos;\\n&apos;)//含站位符使用支持def color = &apos;blue&apos;def interpolatedSlashy = /a $&#123;color&#125; car/assert interpolatedSlashy == &apos;a blue car&apos; 特别注意，一个空的斜线字符串会被Groovy解析器解析为一注释。 字符Characters不像Java，Groovy没有明确的Characters。但是我们可以有如下三种不同的方式来将字符串作为字符处理，譬如： 12345678char c1 = &apos;A&apos; assert c1 instanceof Characterdef c2 = &apos;B&apos; as char assert c2 instanceof Characterdef c3 = (char)&apos;C&apos; assert c3 instanceof Character 数字NumbersGroovy支持各种类型的整型和数值类型，通常支持Java支持的那些，下面我们仔细来说说。 整型Groovy像Java一样支持如下一些整型，byte、char、short、int、long、java.lang.BigInteger。我们在使用中可以像下面例子一样： 12345678910111213141516171819// primitive typesbyte b = 1char c = 2short s = 3int i = 4long l = 5// infinite precisionBigInteger bi = 6int xInt = 077assert xInt == 63int xInt = 0x77assert xInt == 119int xInt = 0b10101111assert xInt == 175 浮点型Groovy像Java一样支持如下一些浮点型，float、double、java.lang.BigDecimal。我们在使用中可以像下面例子一样： 123456789101112// primitive typesfloat f = 1.234double d = 2.345// infinite precisionBigDecimal bd = 3.456assert 1e3 == 1_000.0assert 2E4 == 20_000.0assert 3e+1 == 30.0assert 4E-2 == 0.04 Booleans类型Boolean类型没啥解释的，和其他语言一样，就两个值，如下： 123456def myBooleanVariable = trueboolean untypedBooleanVar = falsebooleanField = true123 比较简单，没啥特例，自行脑补。 Lists类型Groovy同样支持java.util.List类型，在Groovy中同样允许向列表中增加或者删除对象，允许在运行时改变列表的大小，保存在列表中的对象不受类型的限制；此外还可以通过超出列表范围的数来索引列表。如下例子： 123456789101112131415161718192021222324252627282930313233343536373839404142//使用动态Listdef numbers = [1, 2, 3] assert numbers instanceof List assert numbers.size() == 3//List中存储任意类型def heterogeneous = [1, &quot;a&quot;, true]//判断List默认类型def arrayList = [1, 2, 3]assert arrayList instanceof java.util.ArrayList//使用as强转类型def linkedList = [2, 3, 4] as LinkedList assert linkedList instanceof java.util.LinkedList//定义指定类型ListLinkedList otherLinked = [3, 4, 5] assert otherLinked instanceof java.util.LinkedList//定义List使用def letters = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;]//判断item值assert letters[0] == &apos;a&apos; assert letters[1] == &apos;b&apos;//负数下标则从右向左indexassert letters[-1] == &apos;d&apos; assert letters[-2] == &apos;c&apos;//指定item赋值判断letters[2] = &apos;C&apos; assert letters[2] == &apos;C&apos;//给List追加itemletters &lt;&lt; &apos;e&apos; assert letters[ 4] == &apos;e&apos;assert letters[-1] == &apos;e&apos;//获取一段List子集assert letters[1, 3] == [&apos;b&apos;, &apos;d&apos;] assert letters[2..4] == [&apos;C&apos;, &apos;d&apos;, &apos;e&apos;] //多维List支持def multi = [[0, 1], [2, 3]] assert multi[1][0] == 2 Arrays类型Groovy中数组和Java类似，具体如下： 123456789101112131415161718192021222324//定义初始化String数组String[] arrStr = [&apos;Ananas&apos;, &apos;Banana&apos;, &apos;Kiwi&apos;] assert arrStr instanceof String[] assert !(arrStr instanceof List)//使用def定义初始化int数组def numArr = [1, 2, 3] as int[] assert numArr instanceof int[] assert numArr.size() == 3//声明定义多维数组指明宽度def matrix3 = new Integer[3][3] assert matrix3.size() == 3//声明多维数组不指定宽度Integer[][] matrix2 matrix2 = [[1, 2], [3, 4]]assert matrix2 instanceof Integer[][]//数组的元素使用及赋值操作String[] names = [&apos;Cédric&apos;, &apos;Guillaume&apos;, &apos;Jochen&apos;, &apos;Paul&apos;]assert names[0] == &apos;Cédric&apos; names[2] = &apos;Blackdrag&apos; assert names[2] == &apos;Blackdrag&apos; Maps类型Map是“键-值”对的集合，在Groovy中键key不一定是String，可以是任何对象(实际上Groovy中的Map就是java.util.Linke dHashMap)。如下： 123456789101112131415161718//定义一个Mapdef colors = [red: &apos;#FF0000&apos;, green: &apos;#00FF00&apos;, blue: &apos;#0000FF&apos;] //获取一些指定key的value进行判断操作assert colors[&apos;red&apos;] == &apos;#FF0000&apos; assert colors.green == &apos;#00FF00&apos;//给指定key的对赋值value操作与判断 colors[&apos;pink&apos;] = &apos;#FF00FF&apos; colors.yellow = &apos;#FFFF00&apos; assert colors.pink == &apos;#FF00FF&apos;assert colors[&apos;yellow&apos;] == &apos;#FFFF00&apos;//判断Map的类型assert colors instanceof java.util.LinkedHashMap//访问Map中不存在的key为nullassert colors.unknown == null//定义key类型为数字的Mapdef numbers = [1: &apos;one&apos;, 2: &apos;two&apos;]assert numbers[1] == &apos;one&apos; 123456789101112对于Map需要特别注意一种情况，如下：//把一个定义的变量作为Map的key，访问Map的该key是失败的def key = &apos;name&apos;def person = [key: &apos;Guillaume&apos;] assert !person.containsKey(&apos;name&apos;) assert person.containsKey(&apos;key&apos;) //把一个定义的变量作为Map的key的正确写法---添加括弧，访问Map的该key是成功的person = [(key): &apos;Guillaume&apos;] assert person.containsKey(&apos;name&apos;) assert !person.containsKey(&apos;key&apos;) 运算符关于Groovy的运算符介绍类似于上面一样，我们重点突出与Java的不同点，相同点自行脑补。 Groovy支持**次方运算符，如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354assert 2 ** 3 == 8def f = 3f **= 2assert f == 9Groovy非运算符如下：assert (!true) == false assert (!&apos;foo&apos;) == false assert (!&apos;&apos;) == true Groovy支持?.安全占位符，这个运算符主要用于避免空指针异常，譬如：def person = Person.find &#123; it.id == 123 &#125; def name = person?.name assert name == null Groovy支持.@直接域访问操作符，因为Groovy自动支持属性getter方法，但有时候我们有一个自己写的特殊getter方法，当不想调用这个特殊的getter方法则可以用直接域访问操作符。如下：class User &#123; public final String name User(String name) &#123; this.name = name&#125; String getName() &#123; &quot;Name: $name&quot; &#125; &#125;def user = new User(&apos;Bob&apos;)assert user.name == &apos;Name: Bob&apos;assert user.@name == &apos;Bob&apos; 1Groovy支持.&amp;方法指针操作符，因为闭包可以被作为一个方法的参数，如果想让一个方法作为另一个方法的参数则可以将一个方法当成一个闭包作为另一个方法的参数。如下： def list = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;] //常规写法 list.each&#123; println it &#125; String printName(name)&#123; println name &#125; //方法指针操作符写法 list.each(this.&amp;printName) Groovy支持将?:三目运算符简化为二目，如下：123456789101112displayName = user.name ? user.name : &apos;Anonymous&apos; displayName = user.name ?: &apos;Anonymous&apos; 12Groovy支持*.展开运算符，一个集合使用展开运算符可以得到一个元素为原集合各个元素执行后面指定方法所得值的集合，如下：cars = [ new Car(make: &apos;Peugeot&apos;, model: &apos;508&apos;), null, new Car(make: &apos;Renault&apos;, model: &apos;Clio&apos;)]assert cars*.make == [&apos;Peugeot&apos;, null, &apos;Renault&apos;] assert null*.make == null 关于Groovy的其他运算符就不多说，类比Java吧。 程序结构这里主要讨论Groovy的代码组成结构，具体如下细则。 包名包名的定义和作用及含义完全和Java一样，不再介绍，如下： 12// defining a package named com.yoursitepackage com.yoursite Imports引入常规的imports导包操作和Java一样，如下： 1234567891011121314151617181920212223//例1：import groovy.xml.MarkupBuilder// using the imported class to create an objectdef xml = new MarkupBuilder()assert xml != null//例2：import groovy.xml.*def markupBuilder = new MarkupBuilder()assert markupBuilder != nullassert new StreamingMarkupBuilder() != null//例3：import static Boolean.FALSEassert !FALSE//例4：特殊的，相当于用as取别名import static Calendar.getInstance as nowassert now().class == Calendar.getInstance().class 不过要特别注意，Groovy与Java类似，已经帮我们默认导入了一些常用的包，所以在我们使用这些包的类时就不用再像上面那样导入了，如下是自动导入的包列表： 12345678import java.lang.*import java.util.*import java.io.*import java.net.*import groovy.lang.*import groovy.util.*import java.math.BigIntegerimport java.math.BigDecimal 脚本与类（脚本的实质）相对于传统的Java类，一个包含main方法的Groovy类可以如下书写： 123456class Main &#123; static void main(String... args) &#123; println &apos;Groovy world!&apos; &#125;&#125;1 和Java一样，程序会从这个类的main方法开始执行，这是Groovy代码的一种写法，实际上执行Groovy代码完全可以不需要类或main方法，所以更简单的写法如下： 1234567891011121314151617println &apos;Groovy world!&apos;1上面这两中写法其实是一样的，具体我们可以通过如下命令进行编译为class文件：groovyc demo.groovy //编译Groovy源码为class1我们使用反编译工具可以查看到这个demo.groovy类源码如下：import org.codehaus.groovy.runtime.InvokerHelperclass Main extends Script &#123; def run() &#123; println &apos;Groovy world!&apos; &#125; static void main(String[] args) &#123; InvokerHelper.runScript(Main, args) &#125;&#125; 可以看见，上面我们写的groovy文件编译后的class其实是Java类，该类从Script类派生而来（查阅API）；可以发现，每个脚本都会生成一个static main方法，我们执行groovy脚本的实质其实是执行的这个Java类的main方法，脚本源码里所有代码都被放到了run方法中，脚本中定义的方法（该例暂无）都会被定义在Main类中。 通过上面可以发现，Groovy的实质就是Java的class，也就是说他一定会和Java一样存在变量作用域！对哦，前面我们解释变量时竟然没说到这个东东，这里说下吧。看下面例子： 1234567891011121314151617//单个Groovy源码文件，运行会报错找不到num变量def num = 1 def printNum()&#123; println num &#125;//单个Groovy源码文件，运行会报错找不到num变量int num = 1 def printNum()&#123; println num &#125; //单个Groovy源码文件，运行OK成功num = 1 def printNum()&#123; println num &#125; 上面的例子可以发现，我们如果想要在Groovy的方法中使用Groovy的变量则不能有修饰符。然而，如果我们想在B.groovy文件访问A.groovy文件的num变量咋办呢，我们可以使用Field注解，具体操作如下： 1234import groovy.transform.Field;@Field num = 112 哈哈，这就是Groovy的变量作用域了，如果你想知道上面这些写法为啥出错，很简单，自己动手整成Java源码相信你一定可以看懂为啥鸟。 闭包Groovy的闭包（closure）是一个非常重要的概念，闭包是可以用作方法参数的代码块，Groovy的闭包更象是一个代码块或者方法指针，代码在某处被定义然后在其后的调用处执行。 语法定义一个闭包： 123&#123; [closureParameters -&gt; ] statements &#125;//[closureparameters -&gt; ]是可选的逗号分隔的参数列表，参数类似于方法的参数列表，这些参数可以是类型化或非类型化的。 如下给出几个有效的闭包定义例子： 12345678910111213141516171819//最基本的闭包&#123; item++ &#125; //使用-&gt;将参数与代码分离&#123; -&gt; item++ &#125; //使用隐含参数it（后面有介绍）&#123; println it &#125; //使用明确的参数it替代&#123; it -&gt; println it &#125; //使用显示的名为参数&#123; name -&gt; println name &#125; //接受两个参数的闭包&#123; String x, int y -&gt; println &quot;hey $&#123;x&#125; the value is $&#123;y&#125;&quot;&#125;//包含一个参数多个语句的闭包&#123; reader -&gt; def line = reader.readLine() line.trim()&#125; 闭包对象： 一个闭包其实就是一个groovy.lang.Closure类型的实例，如下： //定义一个Closure类型的闭包 1234567def listener = &#123; e -&gt; println &quot;Clicked on $e.source&quot; &#125; assert listener instanceof Closure//定义直接指定为Closure类型的闭包Closure callback = &#123; println &apos;Done!&apos; &#125; Closure&lt;Boolean&gt; isTextFile = &#123; File it -&gt; it.name.endsWith(&apos;.txt&apos;) &#125; 调运闭包： 其实闭包和C语言的函数指针非常像，我们定义好闭包后调用的方法有如下两种形式： 闭包对象.call(参数) 闭包对象(参数) 如下给出例子： 1234567def code = &#123; 123 &#125;assert code() == 123assert code.call() == 123def isOdd = &#123; int i-&gt; i%2 == 1 &#125; assert isOdd(3) == true assert isOdd.call(2) == false 特别注意，如果闭包没定义参数则默认隐含一个名为it的参数，如下例子： 123def isEven = &#123; it%2 == 0 &#125; assert isEven(3) == false assert isEven.call(2) == true 参数普通参数： 一个闭包的普通参数定义必须遵循如下一些原则： 参数类型可选参数名字可选的参数默认值参数必须用逗号分隔如下是一些例子： 1234567891011121314151617def closureWithOneArg = &#123; str -&gt; str.toUpperCase() &#125;assert closureWithOneArg(&apos;groovy&apos;) == &apos;GROOVY&apos;def closureWithOneArgAndExplicitType = &#123; String str -&gt; str.toUpperCase() &#125;assert closureWithOneArgAndExplicitType(&apos;groovy&apos;) == &apos;GROOVY&apos;def closureWithTwoArgs = &#123; a,b -&gt; a+b &#125;assert closureWithTwoArgs(1,2) == 3def closureWithTwoArgsAndExplicitTypes = &#123; int a, int b -&gt; a+b &#125;assert closureWithTwoArgsAndExplicitTypes(1,2) == 3def closureWithTwoArgsAndOptionalTypes = &#123; a, int b -&gt; a+b &#125;assert closureWithTwoArgsAndOptionalTypes(1,2) == 3def closureWithTwoArgAndDefaultValue = &#123; int a, int b=2 -&gt; a+b &#125;assert closureWithTwoArgAndDefaultValue(1) == 3 隐含参数： 1234567891011121314151617当一个闭包没有显式定义一个参数列表时，闭包总是有一个隐式的it参数。如下：def greeting = &#123; &quot;Hello, $it!&quot; &#125;assert greeting(&apos;Patrick&apos;) == &apos;Hello, Patrick!&apos;12上面的类似下面这个例子：def greeting = &#123; it -&gt; &quot;Hello, $it!&quot; &#125;assert greeting(&apos;Patrick&apos;) == &apos;Hello, Patrick!&apos;12当然啦，如果你想声明一个不接受任何参数的闭包，且必须限定为没有参数的调用，那么你必须将它声明为一个空的参数列表，如下：def magicNumber = &#123; -&gt; 42 &#125;// this call will fail because the closure doesn&apos;t accept any argumentmagicNumber(11) 可变长参数： 1234567891011Groovy的闭包支持最后一个参数为不定长可变长度的参数，具体用法如下：def concat1 = &#123; String... args -&gt; args.join(&apos;&apos;) &#125; assert concat1(&apos;abc&apos;,&apos;def&apos;) == &apos;abcdef&apos; def concat2 = &#123; String[] args -&gt; args.join(&apos;&apos;) &#125; assert concat2(&apos;abc&apos;, &apos;def&apos;) == &apos;abcdef&apos;def multiConcat = &#123; int n, String... args -&gt; args.join(&apos;&apos;)*n&#125;assert multiConcat(2, &apos;abc&apos;,&apos;def&apos;) == &apos;abcdefabcdef&apos; 闭包省略调运很多方法的最后一个参数都是一个闭包，我们可以在这样的方法调运时进行略写括弧。比如： 1234567def debugClosure(int num, String str, Closure closure)&#123; //dosomething &#125; debugClosure(1, &quot;groovy&quot;, &#123; println&quot;hello groovy!&quot; &#125;) 可以看见，当闭包作为闭包或方法的最后一个参数时我们可以将闭包从参数圆括号中提取出来接在最后，如果闭包是唯一的一个参数，则闭包或方法参数所在的圆括号也可以省略；对于有多个闭包参数的，只要是在参数声明最后的，均可以按上述方式省略。 GDK(Groovy Development Kit)Groovy除了可以直接使用Java的JDK以外还有自己的一套GDK，其实也就是对JDK的一些类的二次封装罢了；一样，这是GDK官方API文档，写代码中请自行查阅。 I/O操作Groovy提供了很多IO操作的方法，你可以使用Java的那写IO方法，但是没有Groovy的GDK提供的简单牛逼。 读文件操作： 我们先来看一个例子： 123456789//读文件打印脚本new File(&apos;/home/temp&apos;, &apos;haiku.txt&apos;).eachLine &#123; line -&gt; println line&#125;//读文件打印及打印行号脚本new File(baseDir, &apos;haiku.txt&apos;).eachLine &#123; line, nb -&gt; println &quot;Line $nb: $line&quot;&#125; 可以看见，这是一个读文件打印每行的脚本，eachLine方法是GDK中File的方法，eachLine的参数是一个闭包，这里采用了简写省略括弧。 当然了，有时候你可能更加喜欢用Reader来操作，使用Reader时即使抛出异常也会自动关闭IO。如下： 12345678def count = 0, MAXSIZE = 3new File(baseDir,&quot;haiku.txt&quot;).withReader &#123; reader -&gt; while (reader.readLine()) &#123; if (++count &gt; MAXSIZE) &#123; throw new RuntimeException(&apos;Haiku should only have 3 verses&apos;) &#125; &#125;&#125; 接着我们再看几个关于读文件的操作使用，如下： 12345678910111213141516//把读到的文件行内容全部存入List列表中def list = new File(baseDir, &apos;haiku.txt&apos;).collect &#123;it&#125;//把读到的文件行内容全部存入String数组列表中def array = new File(baseDir, &apos;haiku.txt&apos;) as String[]//把读到的文件内容全部转存为byte数组byte[] contents = file.bytes//把读到的文件转为InputStream，切记此方式需要手动关闭流def is = new File(baseDir,&apos;haiku.txt&apos;).newInputStream()// do something ...is.close()//把读到的文件以InputStream闭包操作，此方式不需要手动关闭流new File(baseDir,&apos;haiku.txt&apos;).withInputStream &#123; stream -&gt; // do something ...&#125; 上面介绍了一些常用的文件读操作，其它的具体参见API和GDK吧。 写文件操作： 有了上面的读操作，接下来直接看几个写操作的例子得了，如下： 1234567891011121314151617181920//向一个文件以utf-8编码写三行文字new File(baseDir,&apos;haiku.txt&apos;).withWriter(&apos;utf-8&apos;) &#123; writer -&gt; writer.writeLine &apos;Into the ancient pond&apos; writer.writeLine &apos;A frog jumps&apos; writer.writeLine &apos;Water’s sound!&apos;&#125;//上面的写法可以直接替换为此写法new File(baseDir,&apos;haiku.txt&apos;) &lt;&lt; &apos;&apos;&apos;Into the ancient pondA frog jumpsWater’s sound!&apos;&apos;&apos;//直接以byte数组形式写入文件file.bytes = [66,22,11]//类似上面读操作，可以使用OutputStream进行输出流操作，记得手动关闭def os = new File(baseDir,&apos;data.bin&apos;).newOutputStream()// do something ...os.close()//类似上面读操作，可以使用OutputStream闭包进行输出流操作，不用手动关闭new File(baseDir,&apos;data.bin&apos;).withOutputStream &#123; stream -&gt; // do something ...&#125; 上面介绍了一些常用的文件写操作，其它的具体参见API和GDK吧。 文件树操作： 在脚本环境中，遍历一个文件树是很常见的需求，Groovy提供了多种方法来满足这个需求。如下： 12345678910111213141516171819202122232425//遍历所有指定路径下文件名打印dir.eachFile &#123; file -&gt; println file.name&#125;//遍历所有指定路径下符合正则匹配的文件名打印dir.eachFileMatch(~/.*\\.txt/) &#123; file -&gt; println file.name&#125;//深度遍历打印名字dir.eachFileRecurse &#123; file -&gt; println file.name&#125;//深度遍历打印名字，只包含文件类型dir.eachFileRecurse(FileType.FILES) &#123; file -&gt; println file.name&#125;//允许设置特殊标记规则的遍历操作dir.traverse &#123; file -&gt; if (file.directory &amp;&amp; file.name==&apos;bin&apos;) &#123; FileVisitResult.TERMINATE &#125; else &#123; println file.name FileVisitResult.CONTINUE &#125;&#125; 执行外部程序： Groovy提供一种简单方式来处理执行外部命令行后的输出流操作。如下： 1234def process = &quot;ls -l&quot;.execute() println &quot;Found text $&#123;process.text&#125;&quot;12 execute方法返回一个java.lang.Process对象，支持in、out、err的信息反馈。在看一个例子，如下： 1234def process = &quot;ls -l&quot;.execute() process.in.eachLine &#123; line -&gt; println line &#125; 上面使用闭包操作打印出执行命令行的输入流信息。 有用的工具类操作ConfigSlurper配置：ConfigSlurper是一个配置管理文件读取工具类，类似于Java的*.properties文件，如下： 1234567891011def config = new ConfigSlurper().parse(&apos;&apos;&apos; app.date = new Date() app.age = 42 app &#123; name = &quot;Test$&#123;42&#125;&quot; &#125;&apos;&apos;&apos;)assert config.app.date instanceof Dateassert config.app.age == 42assert config.app.name == &apos;Test42&apos; 上面介绍了一些常用的属性配置操作，其它的具体参见API和GDK吧。 Expando扩展：123456def expando = new Expando()expando.toString = &#123; -&gt; &apos;John&apos; &#125;expando.say = &#123; String s -&gt; &quot;John says: $&#123;s&#125;&quot; &#125;assert expando as String == &apos;John&apos;assert expando.say(&apos;Hi&apos;) == &apos;John says: Hi&apos; 上面介绍了一些常用的拓展操作，其它的具体参见API和GDK吧。 其他操作还有很多其他操作，这里就不一一列举，详情参考官方文档即可，譬如JSON处理、XML解析啥玩意的，自行需求摸索吧。 DSL(Domain Specific Languages)领域相关语言这个就不特殊说明了，只在这里提一下，因为我们前边很多地方已经用过它了，加上我们只是干货基础掌握，所以不做深入探讨。 DSL是一种特定领域的语言（功能领域、业务领域），Groovy是通用的编程语言，所以不是DSL，但是Groovy却对编写全新的DSL提供了很好的支持，这些支持来自于Groovy自身语法的特性，如下： Groovy不需用定义CLASS类就可以直接执行脚本； Groovy语法省略括弧和语句结尾分号等操作； 所以说这个基础入门没必要特别深入理解，简单的前面都用过了，理解DSL作用即可，点到为止，详情参考官方文档。 Groovy脚本基础总结其实没啥总结的，Groovy其实可以当做Java来看待，只是它提供的支持比Java还好而已，在学习Groovy是一定要和Java进行对比学习，这样才能速成基础。","categories":[],"tags":[{"name":"CI-CD","slug":"CI-CD","permalink":"https://banghuaji.github.io/tags/CI-CD/"},{"name":"GROOVY","slug":"GROOVY","permalink":"https://banghuaji.github.io/tags/GROOVY/"}]},{"title":"VPS，虚拟主机，云主机，独立服务器","slug":"cloud-service/VPS，虚拟主机，云主机，独立服务器","date":"2017-11-03T01:30:49.773Z","updated":"2017-11-02T14:15:35.000Z","comments":true,"path":"2017/11/03/cloud-service/VPS，虚拟主机，云主机，独立服务器/","link":"","permalink":"https://banghuaji.github.io/2017/11/03/cloud-service/VPS，虚拟主机，云主机，独立服务器/","excerpt":"","text":"独立服务器 独立服务器，顾名思义，就是一个躺在机房的实实在在的物理服务器，也可理解为你的游戏主机一样。 优点：性能高 缺点：价格高，高可用性低（比如断电，硬盘坏了……） VPS Virtual Private Server 虚拟专用服务器,一般是将一个独立服务器通过虚拟化技术虚拟成多个虚拟专用服务器。 优点：价格便宜缺点：性能低，高可用性低（除了其所在的物理机出问题了会收到影响，虚拟化技术出问题也会收到影响） 云服务器 Elastic Compute Service, 简称ECS 好多人理解云服务器和VPS一样，更有甚者说以前的VPS现在的说法就是云服务器，其实不然，云服务器是一个计算，网络，存储的组合。简单点说就是通过多个CPU，内存，硬盘组成的计算池和存储池和网络的组合。 优点：价格适中，使用灵活，高可用性（单个或多个物理离线不会对整个服务造成太大的影响） 缺点：性能相对较低 虚拟主机Virtual hosts （Vhost）虚拟主机是通过，物理服务器，VPS或者云服务器安装例如CPanel，Plesk等面板搭建的。 总结：如过只是做一个小网站，个人博客等用虚拟主机就可，大点的应用建议用云服务器 虚拟主机市场比较混乱，不同的厂商价格一般会有很大的差异，一般来说看一个虚拟主机的好坏可以从以下几点来看， 主机系统：CloudLinux 更适合多租户虚拟主机，CPanel，Plesk 面板在市场上最受市场欢迎， 一般来说价格相对较贵，使用云服务器最好（比如阿里云），物理服务器也可，一般不选择VPS作为虚拟主机的服务器。 优点：价格低，使用方便缺点：一般来说只能做网站，或应用后端服务器，市场杂乱比较难选购","categories":[],"tags":[{"name":"服务器","slug":"服务器","permalink":"https://banghuaji.github.io/tags/服务器/"}]},{"title":"Groovy脚本基础全攻略","slug":"cicd/Groovy脚本基础全攻略","date":"2017-11-02T15:57:22.402Z","updated":"2017-11-02T15:56:58.974Z","comments":true,"path":"2017/11/02/cicd/Groovy脚本基础全攻略/","link":"","permalink":"https://banghuaji.github.io/2017/11/02/cicd/Groovy脚本基础全攻略/","excerpt":"","text":"背景Groovy脚本基于Java且拓展了Java，所以从某种程度来说掌握Java是学习Groovy的前提，故本文适用于不熟悉Groovy却想快速得到Groovy核心基础干货的Java开发者（注意是Java），因为我的目的不是深入学习Groovy语言，所以本文基本都是靠代码来解释，这样最直观，同时也够干货基础入门Groovy的特点和结构。 Groovy是一种动态语言，它和Java类似（算是Java的升级版，但是又具备脚本语言的特点），都在Java虚拟机中运行。当运行Groovy脚本时它会先被编译成Java类字节码，然后通过JVM虚拟机执行这个Java字节码类。 快速安装指南：我们在写Groovy代码时可以直接使用自己喜欢的文本编辑器编辑OK以后以.groovy后缀保存，然后在终端执行如下命令即可运行： 1$ groovy ./TestFile.groovy 再或者我们还可以使用Intellij IDEA等工具安装groovy插件进行groovy开发，这里不再一一叙述了（配置环境点我），直接给出一个读取指定文件内容打印的例子，如下： 语法基础注释Groovy的单行注释、多行注释、文档注释基本都和Java一样，没啥特殊的，不再细说。只有一种特殊的单行注释需要留意一下即可。如下：12#!/usr/bin/env groovyprintln &quot;Hello from the shebang line&quot; 这种注释通常是用来给UNIX系统声明允许脚本运行的类型的，一般都是固定写法，没啥讲究的。 关键字Groovy有如下一些关键字，我们些代码命名时要注意： 12as、assert、break、case、catch、class、const、continue、def、default、do、else、enum、extends、false、finally、for、goto、if、implements、import、in、instanceof、interface、new、null、package、return、super、switch、this、throw、throws、trait、true、try、while 这玩意和其他语言一样，没啥特殊的，自行脑补。 标识符对于Groovy的标示符和Java还是有些共同点和区别的，特别是引用标示符的区别，具体可以往下看。 普通标识符普通标识符定义和C语言类似，只能以字母、美元符、下划线开始，不能以数字开头。如下例子： 12345678//正确def namedef $namedef name_typedef foo.assert//错误def 5typedef a+b 引用标识符引用标识符出现在点后的表达式中，我们可以如下一样使用： 12345678def map = [:]//引用标示符中出现空格也是对的map.&quot;an identifier with a space and double quotes&quot; = &quot;ALLOWED&quot;//引用标示符中出现横线也是对的map.&apos;with-dash-signs-and-single-quotes&apos; = &quot;ALLOWED&quot;assert map.&quot;an identifier with a space and double quotes&quot; == &quot;ALLOWED&quot;assert map.&apos;with-dash-signs-and-single-quotes&apos; == &quot;ALLOWED&quot; Groovy的所有字符串都可以当作引用标示符定义，如下： 12345678910111213//如下类型字符串作为引用标识符都是对的map.&apos;single quote&apos;map.&quot;double quote&quot;map.&apos;&apos;&apos;triple single quote&apos;&apos;&apos;map.&quot;&quot;&quot;triple double quote&quot;&quot;&quot;map./slashy string/map.$/dollar slashy string/$//稍微特殊的GString，也是对的def firstname = &quot;Homer&quot;map.&quot;Simson-$&#123;firstname&#125;&quot; = &quot;Homer Simson&quot;assert map.&apos;Simson-Homer&apos; == &quot;Homer Simson 字符及字符串Groovy有java.lang.String和groovy.lang.GString两中字符串对象类型，具体如下细说。 单引号字符串单引号字符串是java.lang.String类型的，不支持站位符插值操作，譬如： 12345def name = &apos;Test Groovy!&apos;def body = &apos;Test $name&apos;assert name == &apos;Test Groovy!&apos;assert body == &apos;Test $name&apos; //不会替换$name站位符 123Groovy的字符串可以通过”+“直接拼接，譬如：assert &apos;ab&apos; == &apos;a&apos; + &apos;b&apos; 其中涉及转义字符规则同Java，只用特殊注意”’“的转义即可。 三重单引号字符串三重单引号字符串是java.lang.String类型的，不支持站位符插值操作，可以标示多行字符串，譬如： 123def aMultilineString = &apos;&apos;&apos;line oneline twoline three&apos;&apos;&apos; 三重单引号字符串允许字符串的内容在多行出现，新的行被转换为“\\n”，其他所有的空白字符都被完整的按照文本原样保留；字符开头添加“/”表示字符内容不转义反斜杠“\\”，只有在反斜杠接下来是一个字符u的时候才需要进行转义，因为\\u表示一个unicode转义。如下： 1234567def strippedFirstNewline = &apos;&apos;&apos;\\line oneline twoline three&apos;&apos;&apos;assert !strippedFirstNewline.startsWith(&apos;\\n&apos;) 双引号字符串双引号字符串支持站位插值操作，如果双引号字符串中不包含站位符则是java.lang.String类型的，如果双引号字符串中包含站位符则是groovy.lang.GString类型的。 对于插值占位符我们可以用${}或者$来标示，${}用于一般替代字串或者表达式，$主要用于A.B的形式中，具体如下例子： 123456789def name = &apos;Guillaume&apos; // a plain stringdef greeting = &quot;Hello $&#123;name&#125;&quot;assert greeting.toString() == &apos;Hello Guillaume&apos;def sum = &quot;The sum of 2 and 3 equals $&#123;2 + 3&#125;&quot;assert sum.toString() == &apos;The sum of 2 and 3 equals 5&apos;def person = [name: &apos;Guillaume&apos;, age: 36]assert &quot;$person.name is $person.age years old&quot; == &apos;Guillaume is 36 years old&apos; 特别注意，$只对A.B等有效，如果表达式包含括号（像方法调用）、大括号、闭包等符号则是无效的。譬如： 1234def number = 3.14shouldFail(MissingPropertyException) &#123; println &quot;$number.toString()&quot;&#125; //该代码运行抛出groovy.lang.MissingPropertyException异常，因为Groovy认为去寻找number的名为toString的属性，所以异常 注意，在表达式中访问属性前必须保证属性已经定义好(值为空也可以)，如果使用了未定义的属性会抛出groovy.lang.MissingPropertyException异常。 GString还支持延迟运算，譬如在GString中使用闭包，闭包在调用GString的toString()方法时被延迟执行；闭包中可以有0或1个参数，若指定一个参数，则参数会被传入一个Writer对象，我们可以利用这个Writer对象来写入字符，若没有参数，闭包返回值的toString()方法被调用。譬如： 123456//无参数闭包def sParameterLessClosure = &quot;1 + 2 == $&#123;-&gt; 3&#125;&quot; assert sParameterLessClosure == &apos;1 + 2 == 3&apos;//一个参数闭包def sOneParamClosure = &quot;1 + 2 == $&#123; w -&gt; w &lt;&lt; 3&#125;&quot; assert sOneParamClosure == &apos;1 + 2 == 3&apos; 上面了解了GString的推迟运算特性，下面我们再来看一个牛逼的特性，如下： 12345678910def number = 1 def eagerGString = &quot;value == $&#123;number&#125;&quot;def lazyGString = &quot;value == $&#123; -&gt; number &#125;&quot;assert eagerGString == &quot;value == 1&quot; assert lazyGString == &quot;value == 1&quot; number = 2 assert eagerGString == &quot;value == 1&quot; assert lazyGString == &quot;value == 2&quot; 可以看见，eagerGString是普通的双引号插值站位替换，lazyGString是双引号闭包插值替换，我们可以发现在number变为2以后他们的运算结果就有了差异。可以明显推理到结论，一个普通插值表达式值替换实际是在GString创建的时刻，一个包含闭包的表达式由于延迟运算调运toString()方法，所以会产生一个新的字符串值。 当然了，GString和String即使字符串一样他们的HashCode也不会一样，譬如： 1assert &quot;one: $&#123;1&#125;&quot;.hashCode() != &quot;one: 1&quot;.hashCode() 由于相同字符串的String与GString的HashCode不同，所以我们一定要避免使用GString作为MAP的key，譬如： 1234def key = &quot;a&quot;def m = [&quot;$&#123;key&#125;&quot;: &quot;letter $&#123;key&#125;&quot;] assert m[&quot;a&quot;] == null //由于key的HashCode不同，所以取不到 其中涉及转义字符规则同Java，只用特殊注意””“的转义即可。 多重双引号字符串多重双引号字符串也支持站位插值操作，我们要特别注意在多重双引号字符串中的单引号和双引号转换问题。譬如： 123456789101112def name = &apos;Groovy&apos;def template = &quot;&quot;&quot; Dear Mr $&#123;name&#125;, You&apos;re the winner of the lottery! Yours sincerly, Dave&quot;&quot;&quot;assert template.toString().contains(&apos;Groovy&apos;) 斜线字符串斜线字符串其实和双引号字符串很类似，通常用在正则表达式中，下面我们看几个例子，如下： 1234567891011121314151617//普通使用def fooPattern = /.*foo.*/assert fooPattern == &apos;.*foo.*&apos;//含转义字符使用def escapeSlash = /The character \\/ is a forward slash/assert escapeSlash == &apos;The character / is a forward slash&apos;//多行支持def multilineSlashy = /one two three/assert multilineSlashy.contains(&apos;\\n&apos;)//含站位符使用支持def color = &apos;blue&apos;def interpolatedSlashy = /a $&#123;color&#125; car/assert interpolatedSlashy == &apos;a blue car&apos; 特别注意，一个空的斜线字符串会被Groovy解析器解析为一注释。 字符Characters不像Java，Groovy没有明确的Characters。但是我们可以有如下三种不同的方式来将字符串作为字符处理，譬如： 12345678char c1 = &apos;A&apos; assert c1 instanceof Characterdef c2 = &apos;B&apos; as char assert c2 instanceof Characterdef c3 = (char)&apos;C&apos; assert c3 instanceof Character 数字NumbersGroovy支持各种类型的整型和数值类型，通常支持Java支持的那些，下面我们仔细来说说。 整型Groovy像Java一样支持如下一些整型，byte、char、short、int、long、java.lang.BigInteger。我们在使用中可以像下面例子一样： 12345678910111213141516171819// primitive typesbyte b = 1char c = 2short s = 3int i = 4long l = 5// infinite precisionBigInteger bi = 6int xInt = 077assert xInt == 63int xInt = 0x77assert xInt == 119int xInt = 0b10101111assert xInt == 175 浮点型Groovy像Java一样支持如下一些浮点型，float、double、java.lang.BigDecimal。我们在使用中可以像下面例子一样： 123456789101112// primitive typesfloat f = 1.234double d = 2.345// infinite precisionBigDecimal bd = 3.456assert 1e3 == 1_000.0assert 2E4 == 20_000.0assert 3e+1 == 30.0assert 4E-2 == 0.04 Booleans类型Boolean类型没啥解释的，和其他语言一样，就两个值，如下： 123456def myBooleanVariable = trueboolean untypedBooleanVar = falsebooleanField = true123 比较简单，没啥特例，自行脑补。 Lists类型Groovy同样支持java.util.List类型，在Groovy中同样允许向列表中增加或者删除对象，允许在运行时改变列表的大小，保存在列表中的对象不受类型的限制；此外还可以通过超出列表范围的数来索引列表。如下例子： 123456789101112131415161718192021222324252627282930313233343536373839404142//使用动态Listdef numbers = [1, 2, 3] assert numbers instanceof List assert numbers.size() == 3//List中存储任意类型def heterogeneous = [1, &quot;a&quot;, true]//判断List默认类型def arrayList = [1, 2, 3]assert arrayList instanceof java.util.ArrayList//使用as强转类型def linkedList = [2, 3, 4] as LinkedList assert linkedList instanceof java.util.LinkedList//定义指定类型ListLinkedList otherLinked = [3, 4, 5] assert otherLinked instanceof java.util.LinkedList//定义List使用def letters = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;]//判断item值assert letters[0] == &apos;a&apos; assert letters[1] == &apos;b&apos;//负数下标则从右向左indexassert letters[-1] == &apos;d&apos; assert letters[-2] == &apos;c&apos;//指定item赋值判断letters[2] = &apos;C&apos; assert letters[2] == &apos;C&apos;//给List追加itemletters &lt;&lt; &apos;e&apos; assert letters[ 4] == &apos;e&apos;assert letters[-1] == &apos;e&apos;//获取一段List子集assert letters[1, 3] == [&apos;b&apos;, &apos;d&apos;] assert letters[2..4] == [&apos;C&apos;, &apos;d&apos;, &apos;e&apos;] //多维List支持def multi = [[0, 1], [2, 3]] assert multi[1][0] == 2 Arrays类型Groovy中数组和Java类似，具体如下： 123456789101112131415161718192021222324//定义初始化String数组String[] arrStr = [&apos;Ananas&apos;, &apos;Banana&apos;, &apos;Kiwi&apos;] assert arrStr instanceof String[] assert !(arrStr instanceof List)//使用def定义初始化int数组def numArr = [1, 2, 3] as int[] assert numArr instanceof int[] assert numArr.size() == 3//声明定义多维数组指明宽度def matrix3 = new Integer[3][3] assert matrix3.size() == 3//声明多维数组不指定宽度Integer[][] matrix2 matrix2 = [[1, 2], [3, 4]]assert matrix2 instanceof Integer[][]//数组的元素使用及赋值操作String[] names = [&apos;Cédric&apos;, &apos;Guillaume&apos;, &apos;Jochen&apos;, &apos;Paul&apos;]assert names[0] == &apos;Cédric&apos; names[2] = &apos;Blackdrag&apos; assert names[2] == &apos;Blackdrag&apos; Maps类型Map是“键-值”对的集合，在Groovy中键key不一定是String，可以是任何对象(实际上Groovy中的Map就是java.util.Linke dHashMap)。如下： 123456789101112131415161718//定义一个Mapdef colors = [red: &apos;#FF0000&apos;, green: &apos;#00FF00&apos;, blue: &apos;#0000FF&apos;] //获取一些指定key的value进行判断操作assert colors[&apos;red&apos;] == &apos;#FF0000&apos; assert colors.green == &apos;#00FF00&apos;//给指定key的对赋值value操作与判断 colors[&apos;pink&apos;] = &apos;#FF00FF&apos; colors.yellow = &apos;#FFFF00&apos; assert colors.pink == &apos;#FF00FF&apos;assert colors[&apos;yellow&apos;] == &apos;#FFFF00&apos;//判断Map的类型assert colors instanceof java.util.LinkedHashMap//访问Map中不存在的key为nullassert colors.unknown == null//定义key类型为数字的Mapdef numbers = [1: &apos;one&apos;, 2: &apos;two&apos;]assert numbers[1] == &apos;one&apos; 123456789101112对于Map需要特别注意一种情况，如下：//把一个定义的变量作为Map的key，访问Map的该key是失败的def key = &apos;name&apos;def person = [key: &apos;Guillaume&apos;] assert !person.containsKey(&apos;name&apos;) assert person.containsKey(&apos;key&apos;) //把一个定义的变量作为Map的key的正确写法---添加括弧，访问Map的该key是成功的person = [(key): &apos;Guillaume&apos;] assert person.containsKey(&apos;name&apos;) assert !person.containsKey(&apos;key&apos;) 运算符关于Groovy的运算符介绍类似于上面一样，我们重点突出与Java的不同点，相同点自行脑补。 Groovy支持**次方运算符，如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354assert 2 ** 3 == 8def f = 3f **= 2assert f == 9Groovy非运算符如下：assert (!true) == false assert (!&apos;foo&apos;) == false assert (!&apos;&apos;) == true Groovy支持?.安全占位符，这个运算符主要用于避免空指针异常，譬如：def person = Person.find &#123; it.id == 123 &#125; def name = person?.name assert name == null Groovy支持.@直接域访问操作符，因为Groovy自动支持属性getter方法，但有时候我们有一个自己写的特殊getter方法，当不想调用这个特殊的getter方法则可以用直接域访问操作符。如下：class User &#123; public final String name User(String name) &#123; this.name = name&#125; String getName() &#123; &quot;Name: $name&quot; &#125; &#125;def user = new User(&apos;Bob&apos;)assert user.name == &apos;Name: Bob&apos;assert user.@name == &apos;Bob&apos; 1Groovy支持.&amp;方法指针操作符，因为闭包可以被作为一个方法的参数，如果想让一个方法作为另一个方法的参数则可以将一个方法当成一个闭包作为另一个方法的参数。如下： def list = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;] //常规写法 list.each&#123; println it &#125; String printName(name)&#123; println name &#125; //方法指针操作符写法 list.each(this.&amp;printName) Groovy支持将?:三目运算符简化为二目，如下：123456789101112displayName = user.name ? user.name : &apos;Anonymous&apos; displayName = user.name ?: &apos;Anonymous&apos; 12Groovy支持*.展开运算符，一个集合使用展开运算符可以得到一个元素为原集合各个元素执行后面指定方法所得值的集合，如下：cars = [ new Car(make: &apos;Peugeot&apos;, model: &apos;508&apos;), null, new Car(make: &apos;Renault&apos;, model: &apos;Clio&apos;)]assert cars*.make == [&apos;Peugeot&apos;, null, &apos;Renault&apos;] assert null*.make == null 关于Groovy的其他运算符就不多说，类比Java吧。 程序结构这里主要讨论Groovy的代码组成结构，具体如下细则。 包名包名的定义和作用及含义完全和Java一样，不再介绍，如下： 12// defining a package named com.yoursitepackage com.yoursite Imports引入常规的imports导包操作和Java一样，如下： 1234567891011121314151617181920212223//例1：import groovy.xml.MarkupBuilder// using the imported class to create an objectdef xml = new MarkupBuilder()assert xml != null//例2：import groovy.xml.*def markupBuilder = new MarkupBuilder()assert markupBuilder != nullassert new StreamingMarkupBuilder() != null//例3：import static Boolean.FALSEassert !FALSE//例4：特殊的，相当于用as取别名import static Calendar.getInstance as nowassert now().class == Calendar.getInstance().class 不过要特别注意，Groovy与Java类似，已经帮我们默认导入了一些常用的包，所以在我们使用这些包的类时就不用再像上面那样导入了，如下是自动导入的包列表： 12345678import java.lang.*import java.util.*import java.io.*import java.net.*import groovy.lang.*import groovy.util.*import java.math.BigIntegerimport java.math.BigDecimal 脚本与类（脚本的实质）相对于传统的Java类，一个包含main方法的Groovy类可以如下书写： 123456class Main &#123; static void main(String... args) &#123; println &apos;Groovy world!&apos; &#125;&#125;1 和Java一样，程序会从这个类的main方法开始执行，这是Groovy代码的一种写法，实际上执行Groovy代码完全可以不需要类或main方法，所以更简单的写法如下： 1234567891011121314151617println &apos;Groovy world!&apos;1上面这两中写法其实是一样的，具体我们可以通过如下命令进行编译为class文件：groovyc demo.groovy //编译Groovy源码为class1我们使用反编译工具可以查看到这个demo.groovy类源码如下：import org.codehaus.groovy.runtime.InvokerHelperclass Main extends Script &#123; def run() &#123; println &apos;Groovy world!&apos; &#125; static void main(String[] args) &#123; InvokerHelper.runScript(Main, args) &#125;&#125; 可以看见，上面我们写的groovy文件编译后的class其实是Java类，该类从Script类派生而来（查阅API）；可以发现，每个脚本都会生成一个static main方法，我们执行groovy脚本的实质其实是执行的这个Java类的main方法，脚本源码里所有代码都被放到了run方法中，脚本中定义的方法（该例暂无）都会被定义在Main类中。 通过上面可以发现，Groovy的实质就是Java的class，也就是说他一定会和Java一样存在变量作用域！对哦，前面我们解释变量时竟然没说到这个东东，这里说下吧。看下面例子： 1234567891011121314151617//单个Groovy源码文件，运行会报错找不到num变量def num = 1 def printNum()&#123; println num &#125;//单个Groovy源码文件，运行会报错找不到num变量int num = 1 def printNum()&#123; println num &#125; //单个Groovy源码文件，运行OK成功num = 1 def printNum()&#123; println num &#125; 上面的例子可以发现，我们如果想要在Groovy的方法中使用Groovy的变量则不能有修饰符。然而，如果我们想在B.groovy文件访问A.groovy文件的num变量咋办呢，我们可以使用Field注解，具体操作如下： 1234import groovy.transform.Field;@Field num = 112 哈哈，这就是Groovy的变量作用域了，如果你想知道上面这些写法为啥出错，很简单，自己动手整成Java源码相信你一定可以看懂为啥鸟。 闭包Groovy的闭包（closure）是一个非常重要的概念，闭包是可以用作方法参数的代码块，Groovy的闭包更象是一个代码块或者方法指针，代码在某处被定义然后在其后的调用处执行。 语法定义一个闭包： 123&#123; [closureParameters -&gt; ] statements &#125;//[closureparameters -&gt; ]是可选的逗号分隔的参数列表，参数类似于方法的参数列表，这些参数可以是类型化或非类型化的。 如下给出几个有效的闭包定义例子： 12345678910111213141516171819//最基本的闭包&#123; item++ &#125; //使用-&gt;将参数与代码分离&#123; -&gt; item++ &#125; //使用隐含参数it（后面有介绍）&#123; println it &#125; //使用明确的参数it替代&#123; it -&gt; println it &#125; //使用显示的名为参数&#123; name -&gt; println name &#125; //接受两个参数的闭包&#123; String x, int y -&gt; println &quot;hey $&#123;x&#125; the value is $&#123;y&#125;&quot;&#125;//包含一个参数多个语句的闭包&#123; reader -&gt; def line = reader.readLine() line.trim()&#125; 闭包对象： 一个闭包其实就是一个groovy.lang.Closure类型的实例，如下： //定义一个Closure类型的闭包 1234567def listener = &#123; e -&gt; println &quot;Clicked on $e.source&quot; &#125; assert listener instanceof Closure//定义直接指定为Closure类型的闭包Closure callback = &#123; println &apos;Done!&apos; &#125; Closure&lt;Boolean&gt; isTextFile = &#123; File it -&gt; it.name.endsWith(&apos;.txt&apos;) &#125; 调运闭包： 其实闭包和C语言的函数指针非常像，我们定义好闭包后调用的方法有如下两种形式： 闭包对象.call(参数) 闭包对象(参数) 如下给出例子： 1234567def code = &#123; 123 &#125;assert code() == 123assert code.call() == 123def isOdd = &#123; int i-&gt; i%2 == 1 &#125; assert isOdd(3) == true assert isOdd.call(2) == false 特别注意，如果闭包没定义参数则默认隐含一个名为it的参数，如下例子： 123def isEven = &#123; it%2 == 0 &#125; assert isEven(3) == false assert isEven.call(2) == true 参数普通参数： 一个闭包的普通参数定义必须遵循如下一些原则： 参数类型可选参数名字可选的参数默认值参数必须用逗号分隔如下是一些例子： 1234567891011121314151617def closureWithOneArg = &#123; str -&gt; str.toUpperCase() &#125;assert closureWithOneArg(&apos;groovy&apos;) == &apos;GROOVY&apos;def closureWithOneArgAndExplicitType = &#123; String str -&gt; str.toUpperCase() &#125;assert closureWithOneArgAndExplicitType(&apos;groovy&apos;) == &apos;GROOVY&apos;def closureWithTwoArgs = &#123; a,b -&gt; a+b &#125;assert closureWithTwoArgs(1,2) == 3def closureWithTwoArgsAndExplicitTypes = &#123; int a, int b -&gt; a+b &#125;assert closureWithTwoArgsAndExplicitTypes(1,2) == 3def closureWithTwoArgsAndOptionalTypes = &#123; a, int b -&gt; a+b &#125;assert closureWithTwoArgsAndOptionalTypes(1,2) == 3def closureWithTwoArgAndDefaultValue = &#123; int a, int b=2 -&gt; a+b &#125;assert closureWithTwoArgAndDefaultValue(1) == 3 隐含参数： 1234567891011121314151617当一个闭包没有显式定义一个参数列表时，闭包总是有一个隐式的it参数。如下：def greeting = &#123; &quot;Hello, $it!&quot; &#125;assert greeting(&apos;Patrick&apos;) == &apos;Hello, Patrick!&apos;12上面的类似下面这个例子：def greeting = &#123; it -&gt; &quot;Hello, $it!&quot; &#125;assert greeting(&apos;Patrick&apos;) == &apos;Hello, Patrick!&apos;12当然啦，如果你想声明一个不接受任何参数的闭包，且必须限定为没有参数的调用，那么你必须将它声明为一个空的参数列表，如下：def magicNumber = &#123; -&gt; 42 &#125;// this call will fail because the closure doesn&apos;t accept any argumentmagicNumber(11) 可变长参数： 1234567891011Groovy的闭包支持最后一个参数为不定长可变长度的参数，具体用法如下：def concat1 = &#123; String... args -&gt; args.join(&apos;&apos;) &#125; assert concat1(&apos;abc&apos;,&apos;def&apos;) == &apos;abcdef&apos; def concat2 = &#123; String[] args -&gt; args.join(&apos;&apos;) &#125; assert concat2(&apos;abc&apos;, &apos;def&apos;) == &apos;abcdef&apos;def multiConcat = &#123; int n, String... args -&gt; args.join(&apos;&apos;)*n&#125;assert multiConcat(2, &apos;abc&apos;,&apos;def&apos;) == &apos;abcdefabcdef&apos; 闭包省略调运很多方法的最后一个参数都是一个闭包，我们可以在这样的方法调运时进行略写括弧。比如： 1234567def debugClosure(int num, String str, Closure closure)&#123; //dosomething &#125; debugClosure(1, &quot;groovy&quot;, &#123; println&quot;hello groovy!&quot; &#125;) 可以看见，当闭包作为闭包或方法的最后一个参数时我们可以将闭包从参数圆括号中提取出来接在最后，如果闭包是唯一的一个参数，则闭包或方法参数所在的圆括号也可以省略；对于有多个闭包参数的，只要是在参数声明最后的，均可以按上述方式省略。 GDK(Groovy Development Kit)Groovy除了可以直接使用Java的JDK以外还有自己的一套GDK，其实也就是对JDK的一些类的二次封装罢了；一样，这是GDK官方API文档，写代码中请自行查阅。 I/O操作Groovy提供了很多IO操作的方法，你可以使用Java的那写IO方法，但是没有Groovy的GDK提供的简单牛逼。 读文件操作： 我们先来看一个例子： 123456789//读文件打印脚本new File(&apos;/home/temp&apos;, &apos;haiku.txt&apos;).eachLine &#123; line -&gt; println line&#125;//读文件打印及打印行号脚本new File(baseDir, &apos;haiku.txt&apos;).eachLine &#123; line, nb -&gt; println &quot;Line $nb: $line&quot;&#125; 可以看见，这是一个读文件打印每行的脚本，eachLine方法是GDK中File的方法，eachLine的参数是一个闭包，这里采用了简写省略括弧。 当然了，有时候你可能更加喜欢用Reader来操作，使用Reader时即使抛出异常也会自动关闭IO。如下： 12345678def count = 0, MAXSIZE = 3new File(baseDir,&quot;haiku.txt&quot;).withReader &#123; reader -&gt; while (reader.readLine()) &#123; if (++count &gt; MAXSIZE) &#123; throw new RuntimeException(&apos;Haiku should only have 3 verses&apos;) &#125; &#125;&#125; 接着我们再看几个关于读文件的操作使用，如下： 12345678910111213141516//把读到的文件行内容全部存入List列表中def list = new File(baseDir, &apos;haiku.txt&apos;).collect &#123;it&#125;//把读到的文件行内容全部存入String数组列表中def array = new File(baseDir, &apos;haiku.txt&apos;) as String[]//把读到的文件内容全部转存为byte数组byte[] contents = file.bytes//把读到的文件转为InputStream，切记此方式需要手动关闭流def is = new File(baseDir,&apos;haiku.txt&apos;).newInputStream()// do something ...is.close()//把读到的文件以InputStream闭包操作，此方式不需要手动关闭流new File(baseDir,&apos;haiku.txt&apos;).withInputStream &#123; stream -&gt; // do something ...&#125; 上面介绍了一些常用的文件读操作，其它的具体参见API和GDK吧。 写文件操作： 有了上面的读操作，接下来直接看几个写操作的例子得了，如下： 1234567891011121314151617181920//向一个文件以utf-8编码写三行文字new File(baseDir,&apos;haiku.txt&apos;).withWriter(&apos;utf-8&apos;) &#123; writer -&gt; writer.writeLine &apos;Into the ancient pond&apos; writer.writeLine &apos;A frog jumps&apos; writer.writeLine &apos;Water’s sound!&apos;&#125;//上面的写法可以直接替换为此写法new File(baseDir,&apos;haiku.txt&apos;) &lt;&lt; &apos;&apos;&apos;Into the ancient pondA frog jumpsWater’s sound!&apos;&apos;&apos;//直接以byte数组形式写入文件file.bytes = [66,22,11]//类似上面读操作，可以使用OutputStream进行输出流操作，记得手动关闭def os = new File(baseDir,&apos;data.bin&apos;).newOutputStream()// do something ...os.close()//类似上面读操作，可以使用OutputStream闭包进行输出流操作，不用手动关闭new File(baseDir,&apos;data.bin&apos;).withOutputStream &#123; stream -&gt; // do something ...&#125; 上面介绍了一些常用的文件写操作，其它的具体参见API和GDK吧。 文件树操作： 在脚本环境中，遍历一个文件树是很常见的需求，Groovy提供了多种方法来满足这个需求。如下： 12345678910111213141516171819202122232425//遍历所有指定路径下文件名打印dir.eachFile &#123; file -&gt; println file.name&#125;//遍历所有指定路径下符合正则匹配的文件名打印dir.eachFileMatch(~/.*\\.txt/) &#123; file -&gt; println file.name&#125;//深度遍历打印名字dir.eachFileRecurse &#123; file -&gt; println file.name&#125;//深度遍历打印名字，只包含文件类型dir.eachFileRecurse(FileType.FILES) &#123; file -&gt; println file.name&#125;//允许设置特殊标记规则的遍历操作dir.traverse &#123; file -&gt; if (file.directory &amp;&amp; file.name==&apos;bin&apos;) &#123; FileVisitResult.TERMINATE &#125; else &#123; println file.name FileVisitResult.CONTINUE &#125;&#125; 执行外部程序： Groovy提供一种简单方式来处理执行外部命令行后的输出流操作。如下： 1234def process = &quot;ls -l&quot;.execute() println &quot;Found text $&#123;process.text&#125;&quot;12 execute方法返回一个java.lang.Process对象，支持in、out、err的信息反馈。在看一个例子，如下： 1234def process = &quot;ls -l&quot;.execute() process.in.eachLine &#123; line -&gt; println line &#125; 上面使用闭包操作打印出执行命令行的输入流信息。 有用的工具类操作ConfigSlurper配置：ConfigSlurper是一个配置管理文件读取工具类，类似于Java的*.properties文件，如下： 1234567891011def config = new ConfigSlurper().parse(&apos;&apos;&apos; app.date = new Date() app.age = 42 app &#123; name = &quot;Test$&#123;42&#125;&quot; &#125;&apos;&apos;&apos;)assert config.app.date instanceof Dateassert config.app.age == 42assert config.app.name == &apos;Test42&apos; 上面介绍了一些常用的属性配置操作，其它的具体参见API和GDK吧。 Expando扩展：123456def expando = new Expando()expando.toString = &#123; -&gt; &apos;John&apos; &#125;expando.say = &#123; String s -&gt; &quot;John says: $&#123;s&#125;&quot; &#125;assert expando as String == &apos;John&apos;assert expando.say(&apos;Hi&apos;) == &apos;John says: Hi&apos; 上面介绍了一些常用的拓展操作，其它的具体参见API和GDK吧。 其他操作还有很多其他操作，这里就不一一列举，详情参考官方文档即可，譬如JSON处理、XML解析啥玩意的，自行需求摸索吧。 DSL(Domain Specific Languages)领域相关语言这个就不特殊说明了，只在这里提一下，因为我们前边很多地方已经用过它了，加上我们只是干货基础掌握，所以不做深入探讨。 DSL是一种特定领域的语言（功能领域、业务领域），Groovy是通用的编程语言，所以不是DSL，但是Groovy却对编写全新的DSL提供了很好的支持，这些支持来自于Groovy自身语法的特性，如下： Groovy不需用定义CLASS类就可以直接执行脚本； Groovy语法省略括弧和语句结尾分号等操作； 所以说这个基础入门没必要特别深入理解，简单的前面都用过了，理解DSL作用即可，点到为止，详情参考官方文档。 Groovy脚本基础总结其实没啥总结的，Groovy其实可以当做Java来看待，只是它提供的支持比Java还好而已，在学习Groovy是一定要和Java进行对比学习，这样才能速成基础。","categories":[],"tags":[{"name":"CI-CD","slug":"CI-CD","permalink":"https://banghuaji.github.io/tags/CI-CD/"},{"name":"GROOVY","slug":"GROOVY","permalink":"https://banghuaji.github.io/tags/GROOVY/"}]},{"title":"LINUX实现免密钥登陆","slug":"soft/LINUX实现免密钥登陆","date":"2017-11-02T14:11:17.845Z","updated":"2017-05-25T07:31:25.000Z","comments":true,"path":"2017/11/02/soft/LINUX实现免密钥登陆/","link":"","permalink":"https://banghuaji.github.io/2017/11/02/soft/LINUX实现免密钥登陆/","excerpt":"","text":"github 或者gitlab 设置添加SSH, 避免每次提交重复输入用户名克隆项目二种方式： 使用https url克隆, 复制https url 然后到 git clone https-url 使用 SSH url克隆却需要在克隆之前先配置和添加好 SSH key, 你必须是这个项目的拥有者。否则你是无法添加 SSH key 的。 https 和 SSH 的区别：1、前者可以随意克隆github上的项目，而不管是谁的；而后者则是你必须是你要克隆的项目的拥有者或管理员，且需要先添加 SSH key ，否则无法克隆。 2、https url 在push的时候是需要验证用户名和密码的；而 SSH 在push的时候，是不需要输入用户名的，如果配置SSH key的时候设置了密码，则需要输入密码的，否则直接是不需要输入密码的。 在 github 上添加 SSH key 的步骤：1、首先需要检查你电脑是否已经有 SSH key 运行 git Bash 客户端，输入如下代码： 12$ cd ~/.ssh$ ls 这两个命令就是检查是否已经存在 id_rsa.pub 或 id_dsa.pub 文件，如果文件已经存在，那么你可以跳过步骤2，直接进入步骤3。 2、创建一个 SSH key 1$ ssh-keygen -t rsa -C \"your_email@example.com\" 代码参数含义： -t 指定密钥类型，默认是 rsa ，可以省略。-C 设置注释文字，比如邮箱。-f 指定密钥文件存储文件名。 以上代码省略了 -f 参数，因此，运行上面那条命令后会让你输入一个文件名，用于保存刚才生成的 SSH key 代码，如： Generating public/private rsa key pair. Enter file in which to save the key (/c/Users/you/.ssh/id_rsa): [Press enter]当然，你也可以不输入文件名，使用默认文件名（推荐），那么就会生成 id_rsa 和 id_rsa.pub 两个秘钥文件。 接着又会提示你输入两次密码（该密码是你push文件的时候要输入的密码，而不是github管理者的密码）， 当然，你也可以不输入密码，直接按回车。那么push的时候就不需要输入密码，直接提交到github上了，如： Enter passphrase (empty for no passphrase): Enter same passphrase again:接下来，就会显示如下代码提示，如： 1234Your identification has been saved in /c/Users/you/.ssh/id_rsa.# Your public key has been saved in /c/Users/you/.ssh/id_rsa.pub.# The key fingerprint is:# 01:0f:f4:3b:ca:85:d6:17:a1:7d:f0:68:9d:f0:a2:db your_email@example.com 当你看到上面这段代码的收，那就说明，你的 SSH key 已经创建成功，你只需要添加到github的SSH key上就可以了。 3、添加你的 SSH key 到 github上面去 a、首先你需要拷贝 id_rsa.pub 文件的内容，你可以用编辑器打开文件复制，也可以用git命令复制该文件的内容，如： $ clip &lt; ~/.ssh/id_rsa.pubb、登录你的github账号，从又上角的设置（ Account Settings ）进入，然后点击菜单栏的 SSH key 进入页面添加 SSH key。 c、点击 Add SSH key 按钮添加一个 SSH key 。把你复制的 SSH key 代码粘贴到 key 所对应的输入框中，记得 SSH key 代码的前后不要留有空格或者回车。当然，上面的 Title 所对应的输入框你也可以输入一个该 SSH key 显示在 github 上的一个别名。默认的会使用你的邮件名称。 4、测试一下该SSH key 在git Bash 中输入以下代码 $ ssh -T git@github.com当你输入以上代码时，会有一段警告代码，如： The authenticity of host ‘github.com (207.97.227.239)’ can’t be established. RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48. Are you sure you want to continue connecting (yes/no)?这是正常的，你输入 yes 回车既可。如果你创建 SSH key 的时候设置了密码，接下来就会提示你输入密码，如： Enter passphrase for key ‘/c/Users/Administrator/.ssh/id_rsa’:当然如果你密码输错了，会再要求你输入，知道对了为止。 注意：输入密码时如果输错一个字就会不正确，使用删除键是无法更正的。 密码正确后你会看到下面这段话，如： Hi username! You’ve successfully authenticated, but GitHub does not provide shell access.如果用户名是正确的,你已经成功设置SSH密钥。如果你看到 “access denied” ，者表示拒绝访问，那么你就需要使用 https 去访问，而不是 SSH 。","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"https://banghuaji.github.io/tags/工具/"},{"name":"GIT","slug":"GIT","permalink":"https://banghuaji.github.io/tags/GIT/"}]},{"title":"GIT安装与使用","slug":"soft/GIT安装与使用","date":"2017-11-02T14:11:17.812Z","updated":"2017-11-02T14:12:09.971Z","comments":true,"path":"2017/11/02/soft/GIT安装与使用/","link":"","permalink":"https://banghuaji.github.io/2017/11/02/soft/GIT安装与使用/","excerpt":"","text":"一、安装Git（windows版、其他平台参阅） 去Git的官网，下载安装包，安装时，一路默认https://git-scm.com/download/win 二、配置Git 2.1 在任意地方，创建一个文件夹，保证该文件夹的目录全部是英文 2.2 打开新建的文件夹，在空白处右击，菜单中点选 Git Init Here 2.3 再次右击，菜单中点选Git Bash，弹出命令行 2.4 配置所有本地仓的账号、邮箱 12$ git config --global user.name \"Your Name\" $ git config --global user.email \"email@example.com\" 2.5 为避免每次远程访问输入密码，使用ssh登陆。ssh应该是与本机信息绑定的，所以每台电脑需要单独生成。 1$ ssh-keygen -t rsa -C \"youremail@example.com\" 2.6 ssh只是本地详细，需要在GitLab中备份，才能被验证。打开自己的GitLab，在My Profile中，点击Add Public Key，title随意。 2.7 key中的内容在本机C盘中，C:\\Users\\account（你的账户下），里面有个.ssh文件夹（运行2.5会产生），用文本文档打开id_rsa.pub，将里面的内容全部复制到key中，即可； 2.8 到此，基本配置完毕；我们需要获取GitLab上项目的地址，每个项目地址不同，一般在GitLab的Projects中，能找到跟你相关的所有项目，点开一个项目，就能看到项目地址，然后在Git Bash中输入： 1$ git clone git@github.com:michaelliao/gitskills.git 2.9 在克隆仓库时，Git 通常会自动创建一个名为 master 的分支来跟踪 origin/master，如果需要关联不同的分支，使用命令 1$ git checkout --track origin/br-2.1.2.1 2.10 将数据同步到本地，一般关联后，直接: 1$ git pull 即可完成项目的拉取至此，我们完成了一个在GitLab上的项目，到本地的过程。 More info: 廖雪峰的官方网站","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"https://banghuaji.github.io/tags/工具/"},{"name":"GIT","slug":"GIT","permalink":"https://banghuaji.github.io/tags/GIT/"}]},{"title":"groovy基础","slug":"cicd/groovy语法","date":"2017-10-29T15:54:55.583Z","updated":"2017-10-31T14:58:54.937Z","comments":true,"path":"2017/10/29/cicd/groovy语法/","link":"","permalink":"https://banghuaji.github.io/2017/10/29/cicd/groovy语法/","excerpt":"","text":"安装groovy：12345wget https://dl.bintray.com/groovy/maven/apache-groovy-binary-2.4.7.zipunzip apache-groovy-binary-2.4.7.zipsudo ln -s /home/osboxes/Downloads/groovy-2.4.7/bin/groovy /usr/bin/groovygroovy -vGroovy Version: 2.4.7 JVM: 1.8.0_91 Vendor: Oracle Corporation OS: Linux 基础语法123456789101112131415161718192021#!/usr/bin/env groovy // Hello Worldprintln &quot;Hello world!&quot; // Variables: You can assign values to variables for later usedef x = 1println x x = new java.util.Date()println x x = -3.1499392println x x = falseprintln x x = &quot;Groovy!&quot;println x 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178//Creating an empty listdef technologies = [] /*** Adding a elements to the list ***/// As with Javatechnologies.add(&quot;Grails&quot;) // Left shift adds, and returns the listtechnologies &lt;&lt; &quot;Groovy&quot; // Add multiple elementstechnologies.addAll([&quot;Gradle&quot;,&quot;Griffon&quot;]) /*** Removing elements from the list ***/// As with Javatechnologies.remove(&quot;Griffon&quot;) // Subtraction works alsotechnologies = technologies - &apos;Grails&apos; /*** Iterating Lists ***/// Iterate over elements of a listtechnologies.each &#123; println &quot;Technology: $it&quot;&#125;technologies.eachWithIndex &#123; it, i -&gt; println &quot;$i: $it&quot;&#125; /*** Checking List contents ***///Evaluate if a list contains element(s) (boolean)contained = technologies.contains( &apos;Groovy&apos; ) // Orcontained = &apos;Groovy&apos; in technologies // Check for multiple contentstechnologies.containsAll([&apos;Groovy&apos;,&apos;Grails&apos;]) /*** Sorting Lists ***/ // Sort a list (mutates original list)technologies.sort() // To sort without mutating original, you can do:sortedTechnologies = technologies.sort( false ) /*** Manipulating Lists ***/ //Replace all elements in the listCollections.replaceAll(technologies, &apos;Gradle&apos;, &apos;gradle&apos;) //Shuffle a listCollections.shuffle(technologies, new Random()) //Clear a listtechnologies.clear() //Creating an empty mapdef devMap = [:] //Add valuesdevMap = [&apos;name&apos;:&apos;Roberto&apos;, &apos;framework&apos;:&apos;Grails&apos;, &apos;language&apos;:&apos;Groovy&apos;]devMap.put(&apos;lastName&apos;,&apos;Perez&apos;) //Iterate over elements of a mapdevMap.each &#123; println &quot;$it.key: $it.value&quot; &#125;devMap.eachWithIndex &#123; it, i -&gt; println &quot;$i: $it&quot;&#125; //Evaluate if a map contains a keyassert devMap.containsKey(&apos;name&apos;) //Evaluate if a map contains a valueassert devMap.containsValue(&apos;Roberto&apos;) //Get the keys of a mapprintln devMap.keySet() //Get the values of a mapprintln devMap.values() //Groovy supports the usual if - else syntaxdef x1 = 3 if(x1==1) &#123; println &quot;One&quot;&#125; else if(x1==2) &#123; println &quot;Two&quot;&#125; else &#123; println &quot;X greater than Two&quot;&#125; //Groovy also supports the ternary operator:def y = 10def x2 = (y &gt; 1) ? &quot;worked&quot; : &quot;failed&quot;assert x2 == &quot;worked&quot; //Instead of using the ternary operator://displayName = user.name ? user.name : &apos;Anonymous&apos;//We can write it://displayName = user.name ?: &apos;Anonymous&apos; //For loop//Iterate over a rangedef x3 = 0for (i in 0 .. 30) &#123; x3 += i&#125; //Iterate over a listx4 = 0for( i in [5,3,2,1] ) &#123; x4 += i&#125; //Iterate over an arrayarray = (0..20).toArray()x5 = 0for (i in array) &#123; x5 += i&#125; //Iterate over a mapdef map = [&apos;name&apos;:&apos;Roberto&apos;, &apos;framework&apos;:&apos;Grails&apos;, &apos;language&apos;:&apos;Groovy&apos;]x6 = 0for ( e in map ) &#123; x6 += e.value&#125; /* Closures A Groovy Closure is like a &quot;code block&quot; or a method pointer. It is a piece of code that is defined and then executed at a later point. More info at: http://www.groovy-lang.org/closures.html*/ //Example:def clos = &#123; println &quot;Hello World!&quot; &#125; println &quot;Executing the Closure:&quot;clos() //Passing parameters to a closuredef sum = &#123; a, b -&gt; println a+b &#125;sum(2,4) //Closures may refer to variables not listed in their parameter list.def x7 = 5def multiplyBy = &#123; num -&gt; num * x7 &#125;println multiplyBy(10) // If you have a Closure that takes a single argument, you may omit the// parameter definition of the Closuredef clos2 = &#123; println it &#125;clos2( &quot;hi&quot; ) /* Groovy can memoize closure results [1][2][3]*/def cl = &#123;a, b -&gt; sleep(3000) // simulate some time consuming processing a + b&#125; mem = cl.memoize() def callClosure(a, b) &#123; def start = System.currentTimeMillis() println mem(a, b) println &quot;Inputs(a = $a, b = $b) - took $&#123;System.currentTimeMillis() - start&#125; msecs.&quot;&#125; callClosure(1, 2)callClosure(1, 2)callClosure(2, 3)callClosure(2, 3)callClosure(3, 4)callClosure(3, 4)callClosure(1, 2)callClosure(2, 3)callClosure(3, 4)","categories":[],"tags":[{"name":"CI-CD","slug":"CI-CD","permalink":"https://banghuaji.github.io/tags/CI-CD/"}]},{"title":"pipeline的基础语法","slug":"cicd/pipeline的基础语法","date":"2017-10-29T11:28:47.096Z","updated":"2017-10-29T11:17:52.000Z","comments":true,"path":"2017/10/29/cicd/pipeline的基础语法/","link":"","permalink":"https://banghuaji.github.io/2017/10/29/cicd/pipeline的基础语法/","excerpt":"","text":"命令的执行步骤123456789101112131415Jenkinsfile (Declarative Pipeline)pipeline &#123; agent any stages &#123; stage(&apos;Build&apos;) &#123; steps &#123; sh &apos;echo &quot;Hello World&quot;&apos; sh &apos;&apos;&apos; echo &quot;Multiline shell steps works too&quot; ls -lah &apos;&apos;&apos; &#125; &#125; &#125;&#125; 重试与超时1234567891011121314151617Jenkinsfile (Declarative Pipeline)pipeline &#123; agent any stages &#123; stage(&apos;Deploy&apos;) &#123; steps &#123; retry(3) &#123; sh &apos;./flakey-deploy.sh&apos; &#125; timeout(time: 3, unit: &apos;MINUTES&apos;) &#123; sh &apos;./health-check.sh&apos; &#125; &#125; &#125; &#125;&#125; 123456789101112131415Jenkinsfile (Declarative Pipeline)pipeline &#123; agent any stages &#123; stage(&apos;Deploy&apos;) &#123; steps &#123; timeout(time: 3, unit: &apos;MINUTES&apos;) &#123; retry(5) &#123; sh &apos;./flakey-deploy.sh&apos; &#125; &#125; &#125; &#125; &#125;&#125; 完成1234567891011121314151617181920212223242526272829Jenkinsfile (Declarative Pipeline)pipeline &#123; agent any stages &#123; stage(&apos;Test&apos;) &#123; steps &#123; sh &apos;echo &quot;Fail!&quot;; exit 1&apos; &#125; &#125; &#125; post &#123; always &#123; echo &apos;This will always run&apos; &#125; success &#123; echo &apos;This will run only if successful&apos; &#125; failure &#123; echo &apos;This will run only if failed&apos; &#125; unstable &#123; echo &apos;This will run only if the run was marked as unstable&apos; &#125; changed &#123; echo &apos;This will run only if the state of the Pipeline has changed&apos; echo &apos;For example, if the Pipeline was previously failing but is now successful&apos; &#125; &#125;&#125; 12345678post &#123; always &#123; echo &apos;This will always run&apos; mail to: &apos;YYYY@yoho.cn&apos;, subject: &quot;Failed Pipeline: $&#123;currentBuild.fullDisplayName&#125; ,&amp;&amp; state is $&#123;currentBuild.currentResult&#125;&quot;, body: &quot;Something is wrong with $&#123;env.BUILD_URL&#125;&quot; &#125;&#125; 要求人力投入进行1234567891011121314151617181920212223242526Jenkinsfile (Declarative Pipeline)pipeline &#123; agent any stages &#123; /* &quot;Build&quot; and &quot;Test&quot; stages omitted */ stage(&apos;Deploy - Staging&apos;) &#123; steps &#123; sh &apos;./deploy staging&apos; sh &apos;./run-smoke-tests&apos; &#125; &#125; stage(&apos;Sanity check&apos;) &#123; steps &#123; input &quot;Does the staging environment look ok?&quot; &#125; &#125; stage(&apos;Deploy - Production&apos;) &#123; steps &#123; sh &apos;./deploy production&apos; &#125; &#125; &#125;&#125; 在Pipeline示例的这个阶段，“构建”和“测试”阶段都已成功执行。实际上，“部署”阶段只能在上一阶段成功完成，否则Pipeline将早退。1234567891011121314151617Jenkinsfile (Declarative Pipeline)pipeline &#123; agent any stages &#123; stage(&apos;Deploy&apos;) &#123; when &#123; expression &#123; currentBuild.result == null || currentBuild.result == &apos;SUCCESS&apos; &#125; &#125; steps &#123; sh &apos;make publish&apos; &#125; &#125; &#125;&#125; parallel来使得任务并行地执行1234567891011121314151617181920stage(&apos;test&apos;) &#123; steps &#123; script &#123; parallel ( aaa : &#123; build_if_needed(&apos;aaa&apos;)&#125;, bbb : &#123; build_if_needed(&apos;bbb&apos;)&#125;, ccc : &#123; build_if_needed(&apos;ccc&apos;)&#125;, ddd : &#123; build_if_needed(&apos;ddd&apos;)&#125;, eee : &#123; build_if_needed(&apos;eee&apos;)&#125; ) parallel ( fff : &#123; build_if_needed(&apos;fff&apos;)&#125;, ggg : &#123; build_if_needed(&apos;ggg&apos;)&#125;, hhh : &#123; build_if_needed(&apos;hhh&apos;)&#125;, jjj : &#123; build_if_needed(&apos;jjj&apos;)&#125;, kkk : &#123; build_if_needed(&apos;kkk&apos;)&#125; ) &#125; &#125;&#125; 12345678910111213stage(&apos;test&apos;) &#123; steps &#123; //echo &quot;steps parallel begin&quot; parallel ( aaa : &#123; build_if_needed(&apos;aaa&apos;)&#125;, bbb : &#123; build_if_needed(&apos;bbb&apos;)&#125;, ccc : &#123; build_if_needed(&apos;ccc&apos;)&#125;, ddd : &#123; build_if_needed(&apos;ddd&apos;)&#125;, eee : &#123; build_if_needed(&apos;eee&apos;)&#125; ) //echo &quot;steps parallel end&quot; &#125;&#125; 1234567891011stage(&apos;test&apos;) &#123; steps &#123; //echo &quot;steps parallel begin&quot; parallel firstBranch: &#123; echo &quot;*********** Starting Test&quot; &#125;, secondBranch: &#123; echo &quot;*********** Starting Test2&quot; &#125; //echo &quot;steps parallel end&quot; &#125;&#125; PS:注释采用// 这里面只能有一个step，否则不能够成功 选择对应的环境：12345parallel &apos;integration-tests&apos;:&#123; node(&apos;mvn-3.3&apos;)&#123; ... &#125;&#125;, &apos;functional-tests&apos;:&#123; node(&apos;selenium&apos;)&#123; ... &#125;&#125;","categories":[],"tags":[{"name":"CI-CD","slug":"CI-CD","permalink":"https://banghuaji.github.io/tags/CI-CD/"}]},{"title":"自动化目的以及答疑","slug":"autotest/自动化目的以及答疑","date":"2017-10-08T14:20:13.294Z","updated":"2017-10-08T14:20:05.000Z","comments":true,"path":"2017/10/08/autotest/自动化目的以及答疑/","link":"","permalink":"https://banghuaji.github.io/2017/10/08/autotest/自动化目的以及答疑/","excerpt":"","text":"自动化的目的 把测试从枯燥的重复劳动中解放出来，例如：回归测试等； 协助手工测试完成很难模拟或无法模拟的的工作，例如：篡改服务返回的数据验证前端对各种数据场景的处理，弱网模拟、特殊协议数据包解析验证等； 尽早发现Bug，例如：数据层的存储过程、Package批量调用验证、接口自动化等偏底层的问题； 协助定位问题，现在的自动化提出了更高的要求，例如：接口层发现问题了，可以通过添加的traceID定位到日志错误或错误代码行，app运行中异常可捕获错误日志等； 线上监控报警，现在的自动化不仅限于线下，线上的也已覆盖，测试和运维的工作可能存在交集，我们不能把质量问题寄托于他人，一旦发现问题，立即报警通知到人，让损失到最小。 提高工作效率，这个面有点广，例如，测试环境的自动化编译、打包、部署、持续集成甚至持续交付等。 关于自动化介入的若干问题 是否要考虑成本？ 当然要考虑，我们总会遇到在成本和质量之间找平衡点，可能一些特殊的行业，特殊的项目，质量的权重更高点，如果引入自动化能提高质量，该介入的还是要介入。 是不是只有大公司能做， 小公司和初创公司就不适合搞自动化？这不是绝对的，还是要看公司的资源和人员配备，如果有能力做为什么不？况且小公司的自动化不一定要做到大公司的程度，只要能提高工作效率，提高质量就可以，滴水穿石，聚沙成塔。 自动化何时介入？ 条件许可的还是尽早介入，越是底层的Bug，影响面越广，修复成本也是最低的。但这不是硬性标准，一般公司都是从UI自动化开始积累经验的，拔苗不能助长。 如何开展自动化工作这个信息量比较大，人才和技术就不多说了，我更关心的是做事的方式 抓住业务测试工作中的痛点和领导的痛点，多沟通多交流，优先解决基层的工作痛点，我相信一个好的领导会看到你的责任心和付出； 技术选型和方案可行性调研，多投入时间和精力，有的人性子急，前期做的很快，如果一开始的方向错了，最终会得不偿失； 如果是比较复杂的解决方案，尽量前后端分离、保证各模块的独立性、可融合性、解耦不解体，做到灵活可扩展，要有下一盘大棋的准备。 大家的看法每个公司的所谓的管理层对自动化理解的层面可能不一样，需要根据实际情况来做自动化，至少中心点不能偏离，需要紧扣业务，另外就是要能实际落地，还有一个就是维护成本及投入产出比。 是否要考虑成本？ 当然要考虑，我们总会遇到在成本和质量之间找平衡点，可能一些特殊的行业，特殊的项目，质量的权重更高点，如果引入自动化能提高质量，该介入的还是要介入。抓住业务测试工作中的痛点和领导的痛点，多沟通多交流，优先解决基层的工作痛点，我相信一个好的领导会看到你的责任心和付出 个人的提问看到题主关于自动化的分享， 有几个延伸问题，自己在工作中一直思考，但是一直没有找到合适的答案。 接口自动化和UI自动化的用例是完全重新设计，还是从业务用例中筛选？IF从业务用例中筛选的话，筛选的标准有哪些呢？（PS：接口用例中的接口参数类型的用例设计，暂不考虑）接口自动化和UI自动化，互相之间有影响吗？或者说接口覆盖的用例和UI覆盖的用例之间是否有某种关联？IF有关联，请问需要多大粒度的关联比较合适？ELIF 没关联，请问两者之间各自为战吗？（PS：这样会不会导致测试覆盖率重复呢？）如果UI层的用例Faile，是不是需要定位到对应的接口层？相反，接口层用例faile，是否需要定位到UI层，IF 以上需要，如何有效关联呢？Or 是否需要在分层测试的工程中，让他们互相成为彼此的辅助？ 个人答案：接口自动化和UI自动化的用例是完全重新设计，还是从业务用例中筛选？IF从业务用例中筛选的话，筛选的标准有哪些呢？（PS：接口用例中的接口参数类型的用例设计，暂不考虑）－－我觉得接口自动化案例要重新设计，这里涉及到分层的概念，接口层更关注对数据的验证，处理各种请求参数正交场景下返回数据的正确性，涉及到增、删、改的接口还要关注数据落地的有效性。 接口自动化和UI自动化，互相之间有影响吗？或者说接口覆盖的用例和UI覆盖的用例之间是否有某种关联？IF有关联，请问需要多大粒度的关联比较合适？ELIF 没关联，请问两者之间各自为战吗？（PS：这样会不会导致测试覆盖率重复呢？）－－接口测试不一定和UI测试有关联，传统的接口测试，不需要等UI开发完成就可以介入了，从这点来说属于前置阶段的，通过Mock Client实现的接口测试；－－UI测试和接口测试一定有关联，因为UI层的数据渲染大部分是通过调用接口获取的，在执行UI自动化的同时，有很多眼睛看不到摸不着的接口在来回穿梭，这些不是Mock Client发起的，而是由真实的程序发起的，场景化内部的参数动态关联等一系列问题，程序都会帮你自动处理。所以由UI测试发起的接口测试，只要你能劫持到接口返回的报文，实现起来比传统的要简单多了。 如果UI层的用例Faile，是不是需要定位到对应的接口层？相反，接口层用例faile，是否需要定位到UI层，IF 以上需要，如何有效关联呢？Or 是否需要在分层测试的工程中，让他们互相成为彼此的辅助？－－UI层Fail，接口层不一定Fail，因为即便接口是正确的，也不能保证UI层的数据再处理不会犯错。相反，接口层Fail了，与之相关的UI层必定Fail。如果接口层Fail，我们可以通过一些手段，例如：获取接口关键字、定制traceID，通过这些唯一性标识去定位错误日志或代码行。 转载于Test-Home:quqing","categories":[],"tags":[{"name":"autotest","slug":"autotest","permalink":"https://banghuaji.github.io/tags/autotest/"}]},{"title":"Docker安装与调试","slug":"deploy/docker/Docker(一)--安装","date":"2017-10-01T12:45:15.270Z","updated":"2017-06-13T02:58:32.000Z","comments":true,"path":"2017/10/01/deploy/docker/Docker(一)--安装/","link":"","permalink":"https://banghuaji.github.io/2017/10/01/deploy/docker/Docker(一)--安装/","excerpt":"","text":"linux—centos下面安装docker的官方安装文档：由docker给的文档可以看出它也只是去配置了一个docker的yum源、然后就通过这个源来安装docker了；在这个文档下我们采用手工配置 1https://docs.docker.com/engine/installation/linux/centos/ 必备条件1、LINUX centos 7以上可以通过1uname -r 1234567lsb_release -a[root@localhost docker]# lsb_release -aLSB Version: :core-4.1-amd64:core-4.1-noarchDistributor ID: CentOSDescription: CentOS Linux release 7.2.1511 (Core) Release: 7.2.1511Codename: Core 配置一个docker用的源：1、为docker 增加一个新的yum配置文件；1touch /etc/yum.repos.d/docker.repo 2、docker.repo的内容如下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162[docker-ce-stable]name=Docker CE Stable - $basearchbaseurl=https://download.docker.com/linux/centos/7/$basearch/stableenabled=1gpgcheck=0 #我把这里设置成了0、说明我信任了这个源，不对它的rpm进行检察gpgkey=https://download.docker.com/linux/centos/gpg[docker-ce-stable-debuginfo]name=Docker CE Stable - Debuginfo $basearchbaseurl=https://download.docker.com/linux/centos/7/debug-$basearch/stableenabled=0gpgcheck=1gpgkey=https://download.docker.com/linux/centos/gpg[docker-ce-stable-source]name=Docker CE Stable - Sourcesbaseurl=https://download.docker.com/linux/centos/7/source/stableenabled=0gpgcheck=1gpgkey=https://download.docker.com/linux/centos/gpg[docker-ce-edge]name=Docker CE Edge - $basearchbaseurl=https://download.docker.com/linux/centos/7/$basearch/edgeenabled=0gpgcheck=1gpgkey=https://download.docker.com/linux/centos/gpg[docker-ce-edge-debuginfo]name=Docker CE Edge - Debuginfo $basearchbaseurl=https://download.docker.com/linux/centos/7/debug-$basearch/edgeenabled=0gpgcheck=1gpgkey=https://download.docker.com/linux/centos/gpg[docker-ce-edge-source]name=Docker CE Edge - Sourcesbaseurl=https://download.docker.com/linux/centos/7/source/edgeenabled=0gpgcheck=1gpgkey=https://download.docker.com/linux/centos/gpg[docker-ce-test]name=Docker CE Test - $basearchbaseurl=https://download.docker.com/linux/centos/7/$basearch/testenabled=0gpgcheck=1gpgkey=https://download.docker.com/linux/centos/gpg[docker-ce-test-debuginfo]name=Docker CE Test - Debuginfo $basearchbaseurl=https://download.docker.com/linux/centos/7/debug-$basearch/testenabled=0gpgcheck=1gpgkey=https://download.docker.com/linux/centos/gpg[docker-ce-test-source]name=Docker CE Test - Sourcesbaseurl=https://download.docker.com/linux/centos/7/source/testenabled=0gpgcheck=1gpgkey=https://download.docker.com/linux/centos/gpg 安装docker:12345678910111213141516171819202122232425262728sudo yum install docker-ceLoaded plugins: fastestmirror, langpacksLoading mirror speeds from cached hostfileResolving Dependencies--&gt; Running transaction check---&gt; Package docker-ce.x86_64 0:17.03.1.ce-1.el7.centos will be installed--&gt; Processing Dependency: docker-ce-selinux &gt;= 17.03.1.ce-1.el7.centos for package: docker-ce-17.03.1.ce-1.el7.centos.x86_64--&gt; Running transaction check---&gt; Package docker-ce-selinux.noarch 0:17.03.1.ce-1.el7.centos will be installed--&gt; Finished Dependency ResolutionDependencies Resolved===================================================================================================================================== Package Arch Version Repository Size=====================================================================================================================================Installing: docker-ce x86_64 17.03.1.ce-1.el7.centos docker-ce-stable 19 MInstalling for dependencies: docker-ce-selinux noarch 17.03.1.ce-1.el7.centos docker-ce-stable 28 kTransaction Summary=====================================================================================================================================Install 1 Package (+1 Dependent package)Total download size: 19 MInstalled size: 19 MIs this ok [y/d/N]: y 直接下载rpm包的方式来安装1、我在安装docker的时候发现下载的速度只有3kB/s 然而文件大小有19M；就在我感觉安装无望的时候、我机智的想到了自己直接把rpm下载下来 看了下docker.repo 、发现centos7的源地址是 https://download.docker.com/linux/centos/7/$basearch/stable 所以我只要去1https://download.docker.com/linux/centos/7/x86_64/stable/Packages/ 下载的文件需要注意的版本12docker-ce-17.03.0.ce-1.el7.centos.x86_64.rpm docker-ce-selinux-17.03.0.ce-1.el7.centos.noarch.rpm 安装docker123456789101112131415161718192021222324252627282930313233343536373839404142434445464748lltotal 19096-rwxrwxrwx 1 jianglexing jianglexing 19521288 May 30 20:05 docker-ce-17.03.0.ce-1.el7.centos.x86_64.rpm-rw-r--r-- 1 jianglexing jianglexing 29108 May 30 20:15 docker-ce-selinux-17.03.0.ce-1.el7.centos.noarch.rpm[root@workstudio docker]# yum localinstall *Loaded plugins: fastestmirror, langpacksExamining docker-ce-17.03.0.ce-1.el7.centos.x86_64.rpm: docker-ce-17.03.0.ce-1.el7.centos.x86_64Marking docker-ce-17.03.0.ce-1.el7.centos.x86_64.rpm to be installedExamining docker-ce-selinux-17.03.0.ce-1.el7.centos.noarch.rpm: docker-ce-selinux-17.03.0.ce-1.el7.centos.noarchMarking docker-ce-selinux-17.03.0.ce-1.el7.centos.noarch.rpm to be installedResolving Dependencies--&gt; Running transaction check---&gt; Package docker-ce.x86_64 0:17.03.0.ce-1.el7.centos will be installed---&gt; Package docker-ce-selinux.noarch 0:17.03.0.ce-1.el7.centos will be installed--&gt; Finished Dependency ResolutionDependencies Resolved===================================================================================================================================== Package Arch Version Repository Size=====================================================================================================================================Installing: docker-ce x86_64 17.03.0.ce-1.el7.centos /docker-ce-17.03.0.ce-1.el7.centos.x86_64 65 M docker-ce-selinux noarch 17.03.0.ce-1.el7.centos /docker-ce-selinux-17.03.0.ce-1.el7.centos.noarch 43 kTransaction Summary=====================================================================================================================================Install 2 PackagesTotal size: 65 MInstalled size: 65 MIs this ok [y/d/N]: yDownloading packages:Running transaction checkRunning transaction testTransaction test succeededRunning transaction Installing : docker-ce-selinux-17.03.0.ce-1.el7.centos.noarch 1/2 setsebool: SELinux is disabled.libsemanage.semanage_direct_install_info: Overriding docker module at lower priority 100 with module at priority 400. Installing : docker-ce-17.03.0.ce-1.el7.centos.x86_64 2/2 Verifying : docker-ce-17.03.0.ce-1.el7.centos.x86_64 1/2 Verifying : docker-ce-selinux-17.03.0.ce-1.el7.centos.noarch 2/2 Installed: docker-ce.x86_64 0:17.03.0.ce-1.el7.centos docker-ce-selinux.noarch 0:17.03.0.ce-1.el7.centos Complete! 启动DOCKER12345[root@workstudio docker]# systemctl start docker[root@workstudio docker]# ps -ef | grep dockerroot 4458 1 1 20:22 ? 00:00:00 /usr/bin/dockerdroot 4465 4458 0 20:22 ? 00:00:00 docker-containerd -l unix:///var/run/docker/libcontainerd/docker-containerd.sock --metrics-interval=0 --start-timeout 2m --state-dir /var/run/docker/libcontainerd/containerd --shim docker-containerd-shim --runtime docker-runcroot 4589 4333 0 20:22 pts/1 00:00:00 grep --color=auto docker 测试docker是否能成功运行有可能遇到无法下载的问题：需要多试几次，123Unable to find image &apos;hello-world:latest&apos; locallydocker: Error response from daemon: Get https://registry-1.docker.io/v2/: dial tcp: lookup registry-1.docker.io on 223.5.5.5:53: read udp 192.168.103.71:56024-&gt;223.5.5.5:53: i/o timeout.See &apos;docker run --help&apos;. 正确展示 1234567891011121314151617181920212223242526[root@workstudio docker]# docker run hello-worldUnable to find image &apos;hello-world:latest&apos; locallylatest: Pulling from library/hello-world78445dd45222: Pull complete Digest: sha256:c5515758d4c5e1e838e9cd307f6c6a0d620b5e07e6f927b07d05f6d12a1ac8d7Status: Downloaded newer image for hello-world:latestHello from Docker!This message shows that your installation appears to be working correctly.To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub. 3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal.To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bashShare images, automate workflows, and more with a free Docker ID: https://cloud.docker.com/For more examples and ideas, visit: https://docs.docker.com/engine/userguide/","categories":[],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://banghuaji.github.io/tags/Docker/"}]},{"title":"JAVA基础知识","slug":"language/java/JAVA基础篇","date":"2017-10-01T12:45:15.113Z","updated":"2017-10-31T14:13:44.137Z","comments":true,"path":"2017/10/01/language/java/JAVA基础篇/","link":"","permalink":"https://banghuaji.github.io/2017/10/01/language/java/JAVA基础篇/","excerpt":"","text":"==符的使用1234Integer a = 1000,b=1000; Integer c = 100,d=100; System.out.println(a==b); //falseSystem.out.println(c==d); //true 查看其中原理 首先公布下答案， 运行代码，我们会得到 false true。我们知道==比较的是两个对象的引用，这里的abcd都是新建出来的对象，按理说都应该输入false才对。这就是这道题的有趣之处，无论是面试题还是论坛讨论区，这道题的出场率都很高。原理其实很简单，我们去看下Integer.Java这个类就了然了。 1234567891011121314public static Integer valueOf(int i) &#123; return i &gt;= 128 || i &lt; -128 ? new Integer(i) : SMALL_VALUES[i + 128]; &#125; /** * A cache of instances used by &#123;@link Integer#valueOf(int)&#125; and auto-boxing */ private static final Integer[] SMALL_VALUES = new Integer[256]; static &#123; for (int i = -128; i &lt; 128; i++) &#123; SMALL_VALUES[i + 128] = new Integer(i); &#125; &#125; 当我们声明一个Integer c = 100;的时候。此时会进行自动装箱操作，简单点说，也就是把基本数据类型转换成Integer对象，而转换成Integer对象正是调用的valueOf方法，可以看到，Integer中把-128-127 缓存了下来。官方解释是小的数字使用的频率比较高，所以为了优化性能，把这之间的数缓存了下来。这就是为什么这道题的答案回事false和ture了。当声明的Integer对象的值在-128-127之间的时候，引用的是同一个对象，所以结果是true。 123456Integer a = new Integer(1000); int b = 1000; Integer c = new Integer(10); Integer d = new Integer(10); System.out.println(a == b); System.out.println(c == d); 正确答案： true 、false 看到这个答案很多小伙伴又会不解，先来说下第二个，按第一题来说Integer不是把-128-127缓存起来了吗？这不是应该是true嘛，但是你仔细看，这里的Integer是我们自己new出来的，并不是用的缓存，所以结果是false。 现在来看第一个为啥又是true了呢？ 首先这里的值为1000，肯定和我们所知的Integer缓存没有关系。既然和缓存没有关系，a是新new出来的对象，按理说输入应该是false才对。但是注意b这里是int类型。当int和Integer进行==比较的时候，Java会把Integer进行自动拆箱，也就是把Integer转成int类型，所以这里进行比较的是int类型的值，所以结果即为true。 String12345String s1 = &quot;abc&quot;; String s2 = &quot;abc&quot;; String s3 = new String(&quot;abc&quot;); System.out.println(s1 == s2); System.out.println(s1 == s3); 按照==的语法来看， 首先s1、s2、s3是三个不同的对象，常理来说，输出都会是false。然而程序的运行结果确实true、false。第二个输出false可以理解，第一个输出true就又让人费解了。我们知道一些基本类型的变量和对象的引用变量都是在函数的栈内存中分配，而堆内存中则存放new 出来的对象和数组。然而除此之外还有一块区域叫做常量池。像我们通常想String s1 = “abc”; 这样申明的字符串对象，其值就是存储在常量池中。当我们创建String s1 = “abc”这样一个对象之后，”abc”就存储到了常量池（也可叫做字符串池）中，当我们创建引用String s2 = “abc” 的时候，Java底层会优先在常量池中查找是否存在”abc”，如果存在则让s2指向这个值，不会重新创建，如果常量池中没有则创建并添加的池中。这就是为什么答案是true 和false的原因。 final关键字1234567891011121314public void mRun(final String name)&#123; new Runnable() &#123; public void run() &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; System.out.println(name); &#125; &#125;.start(); &#125; 这种代码相信大家写过很多，当内部类访问局部变量的时候，需要在局部变量前加final修饰符，不然编译器就会报错。通常我们也是这么干的。好的，第二个问题来了，为什么要加final修饰符？相信大多数小伙伴都没有思考过这个问题，但凡使用的时候，直接加上就得了，从来没去深究过其中的原理。这对于一个优秀的程序员来说是不可取，我们不仅要知其然还要知其所以然。 现在我们来分析一下，为什么要加final关键字。首先内部类的生命周期是成员级别的，而局部变量的生命周期实在方法体之类。也就是说会出现这样一种情况，当mRun方法执行，new 的线程运行，新线程里面会睡一秒。主线程会继续执行，mRun执行完毕，name属性生命周期结束。1秒之后，Syetem.out.printh(name)执行。然而此时name已经寿终正寝，不在内存中了。Java就是为了杜绝这种错误，严格要求内部类中方位局部变量，必须使用final关键字修饰。局部变量被final修饰之后，此时会在内存中保有一份局部变得的复制品，当内部类访问的时候其实访问的是这个复制品。这就好像是把局部变量的生命周期变长了。说到底还是Java工程师提前把这个坑给我们填了，不然不知道又会有多少小伙伴会为了内部类局部变量而发愁了。","categories":[{"name":"Java","slug":"Java","permalink":"https://banghuaji.github.io/categories/Java/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://banghuaji.github.io/tags/JAVA/"}]},{"title":"异步调用线程","slug":"language/java/异步调用","date":"2017-10-01T12:45:14.872Z","updated":"2017-06-08T04:33:39.000Z","comments":true,"path":"2017/10/01/language/java/异步调用/","link":"","permalink":"https://banghuaji.github.io/2017/10/01/language/java/异步调用/","excerpt":"","text":"之前的同事给的一个例子 123456789101112131415161718192021222324252627282930313233343536373839404142import java.util.concurrent.Callable;import java.util.concurrent.CompletableFuture;import java.util.function.Consumer;public class CallbackDemo &#123; public static void main(String[] args) throws InterruptedException &#123; // 异步调用运程方法，结束后数据写入数据库 asyncCall(new Callable&lt;String&gt;() &#123; // &lt;- 这个是请求方法 @Override public String call() throws Exception &#123; // TODO 向远程发送请求 return \"请求结果\"; &#125; &#125;, new Consumer&lt;String&gt;() &#123; // &lt;- 这个是回调方法 @Override public void accept(String s) &#123; System.out.println(s + \"写入数据库\"); &#125; &#125;); Thread.sleep(1000l); &#125; private static &lt;T&gt; void asyncCall(Callable&lt;T&gt; callable, Consumer&lt;T&gt; callback) &#123; CompletableFuture.runAsync(new Runnable() &#123; @Override public void run() &#123; // TODO 远程调用获取结果 result try &#123; T result = callable.call(); callback.accept(result); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;); &#125;&#125;","categories":[],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://banghuaji.github.io/tags/JAVA/"},{"name":"JAVA基础","slug":"JAVA基础","permalink":"https://banghuaji.github.io/tags/JAVA基础/"}]},{"title":"冒泡的排序","slug":"language/java/冒泡排序","date":"2017-10-01T12:45:14.854Z","updated":"2017-06-04T15:33:55.000Z","comments":true,"path":"2017/10/01/language/java/冒泡排序/","link":"","permalink":"https://banghuaji.github.io/2017/10/01/language/java/冒泡排序/","excerpt":"","text":"冒泡的排序1234567891011121314151617181920212223public class BubbleSort&#123; public static void main(String[] args)&#123; int score[] = &#123;67, 69, 75, 87, 89, 90, 99, 100&#125;; for (int i = 0; i &lt; score.length -1; i++)&#123; //最多做n-1趟排序 for(int j = 0 ;j &lt; score.length - i - 1; j++)&#123; //对当前无序区间score[0......length-i-1]进行排序(j的范围很关键，这个范围是在逐步缩小的) if(score[j] &lt; score[j + 1])&#123; //把小的值交换到后面 int temp = score[j]; score[j] = score[j + 1]; score[j + 1] = temp; &#125; &#125; System.out.print(\"第\" + (i + 1) + \"次排序结果：\"); for(int a = 0; a &lt; score.length; a++)&#123; System.out.print(score[a] + \"\\t\"); &#125; System.out.println(\"\"); &#125; System.out.print(\"最终排序结果：\"); for(int a = 0; a &lt; score.length; a++)&#123; System.out.print(score[a] + \"\\t\"); &#125; &#125; &#125;","categories":[],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://banghuaji.github.io/tags/JAVA/"}]},{"title":"jquery select2使用js赋值","slug":"full-stack/WEB/jquery select2使用js赋值","date":"2017-10-01T12:45:05.177Z","updated":"2017-10-01T13:12:21.000Z","comments":true,"path":"2017/10/01/full-stack/WEB/jquery select2使用js赋值/","link":"","permalink":"https://banghuaji.github.io/2017/10/01/full-stack/WEB/jquery select2使用js赋值/","excerpt":"","text":"但是遇到一个问题 jquery select2插件 取值和原来的select标签取值都一样。但是给jquery select2赋值就出现了问题，用传统的select赋值的方式给jquery select2赋值发现不起作用。 最后查看了jquery select2的api文档，也网上搜了很多资料，但是都给得jquery select2赋值方式是：$(“#id”).val(“1”).trigger(“change”); 我感觉这种赋值方式是有问题，虽然这样赋值也行，但我个人不推荐这样赋值，而是使用jquery select2 api 里提到的赋值方式：$(“#id”).val(“1”).select2(); 这样就可以了。","categories":[],"tags":[{"name":"WEB","slug":"WEB","permalink":"https://banghuaji.github.io/tags/WEB/"}]},{"title":"测试现状","slug":"thoughts/测试的现状","date":"2017-10-01T12:45:05.105Z","updated":"2017-06-10T13:45:34.000Z","comments":true,"path":"2017/10/01/thoughts/测试的现状/","link":"","permalink":"https://banghuaji.github.io/2017/10/01/thoughts/测试的现状/","excerpt":"","text":"下面两个文档体现出软件测试的现状测试的主要工作：1、保证质量（本职的工作） 2、背锅？？ welcome to 51testing Testingba工作室 现在很多公司的做法很多所谓的移动互联网公司完全不注重测试，把用户当做一手的测试人员，后台收集bug数据，一周发两个版本也是家常便饭。。。","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://banghuaji.github.io/tags/随笔/"}]},{"title":"高级测试工程师技术基础","slug":"thoughts/高级测试工程师技术基础","date":"2017-10-01T12:45:05.088Z","updated":"2017-06-05T12:20:18.000Z","comments":true,"path":"2017/10/01/thoughts/高级测试工程师技术基础/","link":"","permalink":"https://banghuaji.github.io/2017/10/01/thoughts/高级测试工程师技术基础/","excerpt":"","text":"下面是之前测试总监整理的【高级测试工程师】所应该具备的技能：","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://banghuaji.github.io/tags/随笔/"},{"name":"职业生涯","slug":"职业生涯","permalink":"https://banghuaji.github.io/tags/职业生涯/"}]}]}